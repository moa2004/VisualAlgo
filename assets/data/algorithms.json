[
  {
    "id": "binary_search",
    "name": "Binary Search",
    "category": "Search & Sort",
    "difficulty": "Beginner",
    "description": "Binary search splits a sorted array in half each iteration, eliminating half of the search space until the target value is located or proven absent.",
    "tags": [
      "search",
      "divide and conquer",
      "array"
    ],
    "complexity": {
      "best": "O(1)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) \n        if arr[mid] == target:\n            return mid\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n",
      "java": "\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n",
      "cpp": "\nint binary_search(const std::vector<int>& arr, int target) {\n    int left = 0, right = static_cast<int>(arr.size()) - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n",
      "csharp": "\npublic int BinarySearch(int[] arr, int target) {\n    int left = 0, right = arr.Length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        }\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize search bounds",
        "description": "Point left and right pointers at the beginning and end of the sorted array to define the active search window.",
        "frame": {
          "arrays": [
            {
              "name": "Indices",
              "values": [
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7"
              ],
              "highlightIndices": [
                0,
                7
              ]
            },
            {
              "name": "Values",
              "values": [
                "2",
                "5",
                "8",
                "12",
                "16",
                "23",
                "38",
                "56"
              ],
              "highlightIndices": [
                0,
                7
              ]
            }
          ],
          "annotations": [
            "left=0",
            "right=7"
          ]
        }
      },
      {
        "title": "Narrow the search window",
        "description": "Calculate the midpoint, compare to the target, and shrink the window toward the half that can still contain the value.",
        "frame": {
          "arrays": [
            {
              "name": "Values",
              "values": [
                "2",
                "5",
                "8",
                "12",
                "16",
                "23",
                "38",
                "56"
              ],
              "highlightIndices": [
                3,
                4,
                5
              ]
            }
          ],
          "annotations": [
            "mid=4",
            "arr[mid] > target, move right"
          ]
        }
      },
      {
        "title": "Return match or not found",
        "description": "When the value matches arr[mid], return the index. If the window collapses, report that the target is absent.",
        "frame": {
          "arrays": [
            {
              "name": "Values",
              "values": [
                "2",
                "5",
                "8",
                "12",
                "16",
                "23",
                "38",
                "56"
              ],
              "highlightIndices": [
                3
              ]
            }
          ],
          "annotations": [
            "Found target at index 3"
          ]
        }
      }
    ]
  },
  {
    "id": "merge_sort",
    "name": "Merge Sort",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Merge sort divides the array recursively and merges sorted halves, guaranteeing O(n log n) sorting with a stable merge phase.",
    "tags": [
      "sorting",
      "divide and conquer",
      "stable sort"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) \n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged\n",
      "java": "\npublic void mergeSort(int[] arr) {\n    if (arr.length <= 1) {\n        return;\n    }\n    int mid = arr.length / 2;\n    int[] left = Arrays.copyOfRange(arr, 0, mid);\n    int[] right = Arrays.copyOfRange(arr, mid, arr.length);\n    mergeSort(left);\n    mergeSort(right);\n    merge(arr, left, right);\n}\n\nprivate void merge(int[] result, int[] left, int[] right) {\n    int i = 0, j = 0, k = 0;\n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result[k++] = left[i++];\n        } else {\n            result[k++] = right[j++];\n        }\n    }\n    while (i < left.length) {\n        result[k++] = left[i++];\n    }\n    while (j < right.length) {\n        result[k++] = right[j++];\n    }\n}\n",
      "cpp": "\nvoid merge_sort(std::vector<int>& arr) {\n    if (arr.size() <= 1) return;\n    auto mid = arr.size() / 2;\n    std::vector<int> left(arr.begin(), arr.begin() + mid);\n    std::vector<int> right(arr.begin() + mid, arr.end());\n    merge_sort(left);\n    merge_sort(right);\n    std::merge(left.begin(), left.end(), right.begin(), right.end(), arr.begin());\n}\n",
      "csharp": "\npublic void MergeSort(int[] arr) {\n    if (arr.Length <= 1) {\n        return;\n    }\n    int mid = arr.Length / 2;\n    int[] left = arr[..mid];\n    int[] right = arr[mid..];\n    MergeSort(left);\n    MergeSort(right);\n    Merge(arr, left, right);\n}\n\nprivate void Merge(int[] result, int[] left, int[] right) {\n    int i = 0, j = 0, k = 0;\n    while (i < left.Length && j < right.Length) {\n        if (left[i] <= right[j]) {\n            result[k++] = left[i++];\n        } else {\n            result[k++] = right[j++];\n        }\n    }\n    while (i < left.Length) {\n        result[k++] = left[i++];\n    }\n    while (j < right.Length) {\n        result[k++] = right[j++];\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Split array into halves",
        "description": "Divide the array recursively until each segment contains a single value.",
        "frame": {
          "nodes": [
            {
              "id": "root",
              "label": "array",
              "x": 0.5,
              "y": 0.12
            },
            {
              "id": "left_mid",
              "label": "left",
              "x": 0.3,
              "y": 0.38
            },
            {
              "id": "right_mid",
              "label": "right",
              "x": 0.7,
              "y": 0.38
            },
            {
              "id": "left_leaf",
              "label": "left half",
              "x": 0.18,
              "y": 0.65
            },
            {
              "id": "right_leaf",
              "label": "right half",
              "x": 0.82,
              "y": 0.65
            }
          ],
          "edges": [
            {
              "from": "root",
              "to": "left_mid",
              "directed": true,
              "highlight": true
            },
            {
              "from": "root",
              "to": "right_mid",
              "directed": true,
              "highlight": true
            },
            {
              "from": "left_mid",
              "to": "left_leaf",
              "directed": true,
              "highlight": true
            },
            {
              "from": "right_mid",
              "to": "right_leaf",
              "directed": true,
              "highlight": true
            }
          ],
          "annotations": [
            "Recursively divide halves"
          ]
        }
      },
      {
        "title": "Merge the sorted sublists",
        "description": "Merge two sorted halves by repeatedly picking the smallest front element.",
        "frame": {
          "arrays": [
            {
              "name": "Left",
              "values": [
                "2",
                "5",
                "8"
              ],
              "highlightIndices": [
                0
              ]
            },
            {
              "name": "Right",
              "values": [
                "3",
                "7",
                "9"
              ],
              "highlightIndices": [
                0
              ]
            },
            {
              "name": "Result",
              "values": [
                "2",
                "3",
                "5",
                "7",
                "8",
                "9"
              ],
              "highlightIndices": [
                0,
                1,
                2,
                3
              ]
            }
          ],
          "annotations": [
            "Stable merge"
          ]
        }
      },
      {
        "title": "Propagate sorted sequence upward",
        "description": "Merged results bubble up the recursion tree to form the fully sorted array.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted",
              "values": [
                "2",
                "3",
                "5",
                "7",
                "8",
                "9"
              ],
              "highlightIndices": [
                0,
                5
              ]
            }
          ],
          "nodes": [
            {
              "id": "root",
              "label": "sorted",
              "x": 0.5,
              "y": 0.2,
              "highlight": true
            }
          ],
          "annotations": [
            "Sorted output"
          ]
        }
      }
    ]
  },
  {
    "id": "quick_sort",
    "name": "Quick Sort",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Quick sort partitions the array around a pivot, recursively sorting elements less than and greater than the pivot. Smart pivot choice yields excellent practical performance.",
    "tags": [
      "sorting",
      "divide and conquer",
      "in-place"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n^2)",
      "space": "O(log n)"
    },
    "codeSnippets": {
      "python": "\ndef quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    if low < high:\n        pivot_index = partition(arr, low, high)\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n",
      "java": "\npublic void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pivotIndex = partition(arr, low, high);\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    }\n}\n\nprivate int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n",
      "cpp": "\nvoid quick_sort(std::vector<int>& arr, int low, int high) {\n    if (low < high) {\n        int pivot_index = partition(arr, low, high);\n        quick_sort(arr, low, pivot_index - 1);\n        quick_sort(arr, pivot_index + 1, high);\n    }\n}\n\nint partition(std::vector<int>& arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; ++j) {\n        if (arr[j] <= pivot) {\n            ++i;\n            std::swap(arr[i], arr[j]);\n        }\n    }\n    std::swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n",
      "csharp": "\npublic void QuickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pivotIndex = Partition(arr, low, high);\n        QuickSort(arr, low, pivotIndex - 1);\n        QuickSort(arr, pivotIndex + 1, high);\n    }\n}\n\nprivate int Partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            (arr[i], arr[j]) = (arr[j], arr[i]);\n        }\n    }\n    (arr[i + 1], arr[high]) = (arr[high], arr[i + 1]);\n    return i + 1;\n}\n"
    },
    "steps": [
      {
        "title": "Select pivot",
        "description": "Choose a pivot element (here the last index). Partition elements into two regions: <= pivot and > pivot.",
        "frame": {
          "arrays": [
            {
              "name": "Partition",
              "values": [
                "7",
                "2",
                "5",
                "3",
                "9",
                "4"
              ],
              "highlightIndices": [
                5
              ]
            }
          ],
          "annotations": [
            "pivot = 4"
          ]
        }
      },
      {
        "title": "Partition around pivot",
        "description": "Swap elements to ensure all values to the left of the pivot are smaller, creating two unsorted partitions.",
        "frame": {
          "arrays": [
            {
              "name": "Partitioned",
              "values": [
                "2",
                "3",
                "4",
                "7",
                "9",
                "5"
              ],
              "highlightIndices": [
                2
              ]
            }
          ],
          "annotations": [
            "pivot placed at index 2"
          ]
        }
      },
      {
        "title": "Recurse on subarrays",
        "description": "Recursively apply quick sort to the left and right partitions until each partition is size one.",
        "frame": {
          "nodes": [
            {
              "id": "root",
              "label": "Pivot",
              "x": 0.5,
              "y": 0.2
            },
            {
              "id": "left",
              "label": "<= pivot",
              "x": 0.25,
              "y": 0.5,
              "highlight": true
            },
            {
              "id": "right",
              "label": "> pivot",
              "x": 0.75,
              "y": 0.5,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "root",
              "to": "left",
              "directed": true
            },
            {
              "from": "root",
              "to": "right",
              "directed": true
            }
          ],
          "annotations": [
            "Recursive calls"
          ]
        }
      }
    ]
  },
  {
    "id": "heap_sort",
    "name": "Heap Sort",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Heap sort builds a max-heap and repeatedly extracts the maximum element to produce a sorted array in-place.",
    "tags": [
      "sorting",
      "heap",
      "selection"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n \n        heapify(arr, n, i)\n    for end in range(n - 1, 0, -1):\n        arr[0], arr[end] = arr[end], arr[0]\n        heapify(arr, end, 0)\n\ndef heapify(arr, heap_size, root):\n    largest = root\n    left = 2 * root + 1\n    right = 2 * root + 2\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n    if largest != root:\n        arr[root], arr[largest] = arr[largest], arr[root]\n        heapify(arr, heap_size, largest)\n",
      "java": "\npublic void heapSort(int[] arr) {\n    int n = arr.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    for (int end = n - 1; end > 0; end--) {\n        swap(arr, 0, end);\n        heapify(arr, end, 0);\n    }\n}\n\nprivate void heapify(int[] arr, int heapSize, int root) {\n    int largest = root;\n    int left = 2 * root + 1;\n    int right = 2 * root + 2;\n    if (left < heapSize && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < heapSize && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    if (largest != root) {\n        swap(arr, root, largest);\n        heapify(arr, heapSize, largest);\n    }\n}\n",
      "cpp": "\nvoid heapify(std::vector<int>& arr, int heap_size, int root) {\n    int largest = root;\n    int left = 2 * root + 1;\n    int right = 2 * root + 2;\n    if (left < heap_size && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < heap_size && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    if (largest != root) {\n        std::swap(arr[root], arr[largest]);\n        heapify(arr, heap_size, largest);\n    }\n}\n\nvoid heap_sort(std::vector<int>& arr) {\n    int n = static_cast<int>(arr.size());\n    for (int i = n / 2 - 1; i >= 0; --i) {\n        heapify(arr, n, i);\n    }\n    for (int end = n - 1; end > 0; --end) {\n        std::swap(arr[0], arr[end]);\n        heapify(arr, end, 0);\n    }\n}\n",
      "csharp": "\npublic void HeapSort(int[] arr) {\n    int n = arr.Length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        Heapify(arr, n, i);\n    }\n    for (int end = n - 1; end > 0; end--) {\n        (arr[0], arr[end]) = (arr[end], arr[0]);\n        Heapify(arr, end, 0);\n    }\n}\n\nprivate void Heapify(int[] arr, int heapSize, int root) {\n    int largest = root;\n    int left = 2 * root + 1;\n    int right = 2 * root + 2;\n    if (left < heapSize && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < heapSize && arr[right] > arr[largest]) {\n        largest = right;\n    }\n    if (largest != root) {\n        (arr[root], arr[largest]) = (arr[largest], arr[root]);\n        Heapify(arr, heapSize, largest);\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Build max-heap",
        "description": "Bottom-up heapify ensures the array satisfies the heap property before extraction.",
        "frame": {
          "nodes": [
            {
              "id": "root",
              "label": "10",
              "x": 0.5,
              "y": 0.2,
              "highlight": true
            },
            {
              "id": "n1",
              "label": "7",
              "x": 0.3,
              "y": 0.4
            },
            {
              "id": "n2",
              "label": "5",
              "x": 0.7,
              "y": 0.4
            },
            {
              "id": "n3",
              "label": "3",
              "x": 0.2,
              "y": 0.6
            },
            {
              "id": "n4",
              "label": "4",
              "x": 0.4,
              "y": 0.6
            },
            {
              "id": "n5",
              "label": "2",
              "x": 0.6,
              "y": 0.6
            },
            {
              "id": "n6",
              "label": "1",
              "x": 0.8,
              "y": 0.6
            }
          ],
          "edges": [
            {
              "from": "root",
              "to": "n1",
              "directed": false
            },
            {
              "from": "root",
              "to": "n2",
              "directed": false
            },
            {
              "from": "n1",
              "to": "n3",
              "directed": false
            },
            {
              "from": "n1",
              "to": "n4",
              "directed": false
            },
            {
              "from": "n2",
              "to": "n5",
              "directed": false
            },
            {
              "from": "n2",
              "to": "n6",
              "directed": false
            }
          ],
          "annotations": [
            "Heap property enforced"
          ]
        }
      },
      {
        "title": "Extract maximum",
        "description": "Swap the root with the last element, shrink the heap, and restore heap order from the root.",
        "frame": {
          "arrays": [
            {
              "name": "Heap",
              "values": [
                "10",
                "7",
                "5",
                "3",
                "4",
                "2",
                "1"
              ],
              "highlightIndices": [
                0,
                6
              ]
            }
          ],
          "annotations": [
            "swap root with end"
          ]
        }
      },
      {
        "title": "Repeat until sorted",
        "description": "After each extraction, push the next maximum to the end, leaving a sorted suffix.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted suffix",
              "values": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "7",
                "10"
              ],
              "highlightIndices": [
                4,
                5,
                6
              ]
            }
          ],
          "annotations": [
            "suffix sorted ascending"
          ]
        }
      }
    ]
  },
  {
    "id": "counting_sort",
    "name": "Counting Sort",
    "category": "Search & Sort",
    "difficulty": "Beginner",
    "description": "Counting sort tallies occurrences of each integer within a bounded range, then accumulates counts to position elements in linear time.",
    "tags": [
      "sorting",
      "stable",
      "linear-time"
    ],
    "complexity": {
      "best": "O(n + k)",
      "average": "O(n + k)",
      "worst": "O(n + k)",
      "space": "O(k)"
    },
    "codeSnippets": {
      "python": "\ndef counting_sort(arr, max_value):\n    count = [0] * (max_value + 1)\n    for value in arr:\n        count[value] += 1\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    output = [0] * len(arr)\n    for value in reversed(arr):\n        count[value] -= 1\n        output[count[value]] = value\n    return output\n",
      "java": "\npublic int[] countingSort(int[] arr, int maxValue) {\n    int[] count = new int[maxValue + 1];\n    for (int value : arr) {\n        count[value]++;\n    }\n    for (int i = 1; i < count.length; i++) {\n        count[i] += count[i - 1];\n    }\n    int[] output = new int[arr.length];\n    for (int i = arr.length - 1; i >= 0; i--) {\n        int value = arr[i];\n        count[value]--;\n        output[count[value]] = value;\n    }\n    return output;\n}\n",
      "cpp": "\nstd::vector<int> counting_sort(const std::vector<int>& arr, int max_value) {\n    std::vector<int> count(max_value + 1, 0);\n    for (int value : arr) {\n        count[value]++;\n    }\n    for (std::size_t i = 1; i < count.size(); ++i) {\n        count[i] += count[i - 1];\n    }\n    std::vector<int> output(arr.size());\n    for (int i = static_cast<int>(arr.size()) - 1; i >= 0; --i) {\n        int value = arr[i];\n        output[--count[value]] = value;\n    }\n    return output;\n}\n",
      "csharp": "\npublic int[] CountingSort(int[] arr, int maxValue) {\n    int[] count = new int[maxValue + 1];\n    foreach (var value in arr) {\n        count[value]++;\n    }\n    for (int i = 1; i < count.Length; i++) {\n        count[i] += count[i - 1];\n    }\n    int[] output = new int[arr.Length];\n    for (int i = arr.Length - 1; i >= 0; i--) {\n        int value = arr[i];\n        output[--count[value]] = value;\n    }\n    return output;\n}\n"
    },
    "steps": [
      {
        "title": "Count occurrences",
        "description": "Scan the input to accumulate how many times each value appears within the bounded range.",
        "frame": {
          "arrays": [
            {
              "name": "Input",
              "values": [
                "4",
                "2",
                "2",
                "8",
                "3",
                "3",
                "1"
              ],
              "highlightIndices": [
                0,
                6
              ]
            },
            {
              "name": "Count",
              "values": [
                "0",
                "1",
                "2",
                "0",
                "1",
                "0",
                "0",
                "0",
                "1"
              ],
              "highlightIndices": [
                1,
                2,
                3,
                4,
                8
              ]
            }
          ],
          "annotations": [
            "frequency tally"
          ]
        }
      },
      {
        "title": "Accumulate counts",
        "description": "Transform frequencies into prefix sums so each position indicates the last index of that value in the sorted array.",
        "frame": {
          "arrays": [
            {
              "name": "Prefix count",
              "values": [
                "0",
                "1",
                "3",
                "3",
                "4",
                "4",
                "4",
                "4",
                "5"
              ],
              "highlightIndices": [
                2,
                4,
                8
              ]
            }
          ],
          "annotations": [
            "prefix sums supply positions"
          ]
        }
      },
      {
        "title": "Stable placement",
        "description": "Traverse the input backwards, placing each element in its sorted position and decrementing its accumulator.",
        "frame": {
          "arrays": [
            {
              "name": "Output",
              "values": [
                "1",
                "2",
                "2",
                "3",
                "3",
                "4",
                "8"
              ],
              "highlightIndices": [
                0,
                6
              ]
            }
          ],
          "annotations": [
            "stable sorted result"
          ]
        }
      }
    ]
  },
  {
    "id": "radix_sort",
    "name": "Radix Sort",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Radix sort processes integer keys digit by digit, using a stable counting sort per digit to achieve linear time for bounded digit lengths.",
    "tags": [
      "sorting",
      "non-comparative",
      "stable"
    ],
    "complexity": {
      "best": "O(d(n + k))",
      "average": "O(d(n + k))",
      "worst": "O(d(n + k))",
      "space": "O(n + k)"
    },
    "codeSnippets": {
      "python": "\ndef radix_sort(arr):\n    if not arr:\n        return arr\n    max_value = max(arr)\n    exp = 1\n    while max_value \n        arr = counting_sort_digit(arr, exp)\n        exp *= 10\n    return arr\n\ndef counting_sort_digit(arr, exp):\n    output = [0] * len(arr)\n    count = [0] * 10\n    for value in arr:\n        index = (value \n        count[index] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    for value in reversed(arr):\n        index = (value \n        count[index] -= 1\n        output[count[index]] = value\n    return output\n",
      "java": "\npublic void radixSort(int[] arr) {\n    if (arr.length == 0) return;\n    int maxValue = Arrays.stream(arr).max().orElse(0);\n    for (int exp = 1; maxValue / exp > 0; exp *= 10) {\n        countingSortDigit(arr, exp);\n    }\n}\n\nprivate void countingSortDigit(int[] arr, int exp) {\n    int[] output = new int[arr.length];\n    int[] count = new int[10];\n    for (int value : arr) {\n        int index = (value / exp) % 10;\n        count[index]++;\n    }\n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    for (int i = arr.length - 1; i >= 0; i--) {\n        int value = arr[i];\n        int index = (value / exp) % 10;\n        output[--count[index]] = value;\n    }\n    System.arraycopy(output, 0, arr, 0, arr.length);\n}\n",
      "cpp": "\nvoid counting_sort_digit(std::vector<int>& arr, int exp) {\n    std::vector<int> count(10, 0);\n    std::vector<int> output(arr.size());\n    for (int value : arr) {\n        int index = (value / exp) % 10;\n        count[index]++;\n    }\n    for (int i = 1; i < 10; ++i) {\n        count[i] += count[i - 1];\n    }\n    for (int i = static_cast<int>(arr.size()) - 1; i >= 0; --i) {\n        int value = arr[i];\n        int index = (value / exp) % 10;\n        output[--count[index]] = value;\n    }\n    arr = output;\n}\n\nvoid radix_sort(std::vector<int>& arr) {\n    if (arr.empty()) return;\n    int max_value = *std::max_element(arr.begin(), arr.end());\n    for (int exp = 1; max_value / exp > 0; exp *= 10) {\n        counting_sort_digit(arr, exp);\n    }\n}\n",
      "csharp": "\npublic void RadixSort(int[] arr) {\n    if (arr.Length == 0) return;\n    int maxValue = arr.Max();\n    for (int exp = 1; maxValue / exp > 0; exp *= 10) {\n        CountingSortDigit(arr, exp);\n    }\n}\n\nprivate void CountingSortDigit(int[] arr, int exp) {\n    int[] count = new int[10];\n    int[] output = new int[arr.Length];\n    foreach (var value in arr) {\n        int index = (value / exp) % 10;\n        count[index]++;\n    }\n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    for (int i = arr.Length - 1; i >= 0; i--) {\n        int value = arr[i];\n        int index = (value / exp) % 10;\n        output[--count[index]] = value;\n    }\n    Array.Copy(output, arr, arr.Length);\n}\n"
    },
    "steps": [
      {
        "title": "Process least-significant digit",
        "description": "Use a stable counting sort on the units digit, grouping numbers by their least-significant position.",
        "frame": {
          "arrays": [
            {
              "name": "Numbers",
              "values": [
                "329",
                "457",
                "657",
                "839",
                "436",
                "720",
                "355"
              ],
              "highlightIndices": [
                0,
                6
              ]
            },
            {
              "name": "Digit buckets",
              "values": [
                "0..9"
              ],
              "highlightIndices": [
                9
              ]
            }
          ],
          "annotations": [
            "sort by exp=1"
          ]
        }
      },
      {
        "title": "Advance to next digit",
        "description": "Move to tens, hundreds, etc., always maintaining stability so previous digit ordering is preserved.",
        "frame": {
          "annotations": [
            "exp = 10",
            "exp = 100"
          ]
        }
      },
      {
        "title": "Fully sorted sequence",
        "description": "After processing all digits, the array emerges sorted in ascending order.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted",
              "values": [
                "329",
                "355",
                "436",
                "457",
                "657",
                "720",
                "839"
              ],
              "highlightIndices": [
                0,
                6
              ]
            }
          ],
          "annotations": [
            "stable ascending order"
          ]
        }
      }
    ]
  },
  {
    "id": "bucket_sort",
    "name": "Bucket Sort",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Bucket sort distributes uniformly random data into buckets, sorts each bucket individually, then concatenates results.",
    "tags": [
      "sorting",
      "distribution",
      "stable option"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n + k)",
      "worst": "O(n^2)",
      "space": "O(n + k)"
    },
    "codeSnippets": {
      "python": "\ndef bucket_sort(arr, bucket_count=10):\n    if not arr:\n        return arr\n    buckets = [[] for _ in range(bucket_count)]\n    min_value, max_value = min(arr), max(arr)\n    span = (max_value - min_value + 1) / bucket_count\n    for value in arr:\n        index = int((value - min_value) / span)\n        if index == bucket_count:\n            index -= 1\n        buckets[index].append(value)\n    result = []\n    for bucket in buckets:\n        result.extend(sorted(bucket))\n    return result\n",
      "java": "\npublic List<Double> bucketSort(List<Double> arr, int bucketCount) {\n    if (arr.isEmpty()) return arr;\n    double min = Collections.min(arr);\n    double max = Collections.max(arr);\n    double span = (max - min + 1) / bucketCount;\n    List<List<Double>> buckets = new ArrayList<>(bucketCount);\n    for (int i = 0; i < bucketCount; i++) {\n        buckets.add(new ArrayList<>());\n    }\n    for (double value : arr) {\n        int index = (int) ((value - min) / span);\n        if (index == bucketCount) index--;\n        buckets.get(index).add(value);\n    }\n    List<Double> result = new ArrayList<>(arr.size());\n    for (List<Double> bucket : buckets) {\n        Collections.sort(bucket);\n        result.addAll(bucket);\n    }\n    return result;\n}\n",
      "cpp": "\nstd::vector<double> bucket_sort(const std::vector<double>& arr, int bucket_count = 10) {\n    if (arr.empty()) return {};\n    double min_value = *std::min_element(arr.begin(), arr.end());\n    double max_value = *std::max_element(arr.begin(), arr.end());\n    double span = (max_value - min_value + 1.0) / bucket_count;\n    std::vector<std::vector<double>> buckets(bucket_count);\n    for (double value : arr) {\n        int index = static_cast<int>((value - min_value) / span);\n        if (index >= bucket_count) index = bucket_count - 1;\n        buckets[index].push_back(value);\n    }\n    std::vector<double> result;\n    result.reserve(arr.size());\n    for (auto& bucket : buckets) {\n        std::sort(bucket.begin(), bucket.end());\n        result.insert(result.end(), bucket.begin(), bucket.end());\n    }\n    return result;\n}\n",
      "csharp": "\npublic List<double> BucketSort(List<double> arr, int bucketCount = 10) {\n    if (arr.Count == 0) return arr;\n    double minValue = arr.Min();\n    double maxValue = arr.Max();\n    double span = (maxValue - minValue + 1) / bucketCount;\n    var buckets = Enumerable.Range(0, bucketCount).Select(_ => new List<double>()).ToList();\n    foreach (var value in arr) {\n        int index = (int)((value - minValue) / span);\n        if (index == bucketCount) index--;\n        buckets[index].Add(value);\n    }\n    var result = new List<double>(arr.Count);\n    foreach (var bucket in buckets) {\n        bucket.Sort();\n        result.AddRange(bucket);\n    }\n    return result;\n}\n"
    },
    "steps": [
      {
        "title": "Distribute into buckets",
        "description": "Map each element to a bucket based on its normalized value, ensuring a roughly even distribution.",
        "frame": {
          "annotations": [
            "bucket index = floor((value - min)/span)"
          ]
        }
      },
      {
        "title": "Sort individual buckets",
        "description": "Use insertion sort or another stable sort inside every bucket to order local elements.",
        "frame": {
          "arrays": [
            {
              "name": "Bucket 3",
              "values": [
                "0.31",
                "0.33",
                "0.35"
              ],
              "highlightIndices": [
                0,
                2
              ]
            }
          ],
          "annotations": [
            "each bucket sorted"
          ]
        }
      },
      {
        "title": "Concatenate buckets",
        "description": "Concatenate the buckets in order to obtain the globally sorted sequence.",
        "frame": {
          "arrays": [
            {
              "name": "Result",
              "values": [
                "0.12",
                "0.18",
                "0.25",
                "0.31",
                "0.33",
                "0.35",
                "0.42"
              ],
              "highlightIndices": [
                0,
                6
              ]
            }
          ],
          "annotations": [
            "concatenate in bucket order"
          ]
        }
      }
    ]
  },
  {
    "id": "insertion_sort",
    "name": "Insertion Sort",
    "category": "Search & Sort",
    "difficulty": "Beginner",
    "description": "Insertion sort builds the final sorted array one item at a time by inserting each element into its correct place among previously sorted elements.",
    "tags": [
      "sorting",
      "in-place",
      "stable"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n^2)",
      "worst": "O(n^2)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n",
      "java": "\npublic void insertionSort(int[] arr) {\n    for (int i = 1; i < arr.length; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n",
      "cpp": "\nvoid insertion_sort(std::vector<int>& arr) {\n    for (std::size_t i = 1; i < arr.size(); ++i) {\n        int key = arr[i];\n        int j = static_cast<int>(i) - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            --j;\n        }\n        arr[j + 1] = key;\n    }\n}\n",
      "csharp": "\npublic void InsertionSort(int[] arr) {\n    for (int i = 1; i < arr.Length; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Consider next element",
        "description": "Treat elements at indices < i as sorted; pull arr[i] out for insertion.",
        "frame": {
          "arrays": [
            {
              "name": "Working array",
              "values": [
                "5",
                "2",
                "4",
                "6",
                "1",
                "3"
              ],
              "highlightIndices": [
                0,
                1
              ]
            }
          ],
          "annotations": [
            "key = 2"
          ]
        }
      },
      {
        "title": "Shift larger elements",
        "description": "Shift larger sorted elements one position to the right to make space for the key.",
        "frame": {
          "arrays": [
            {
              "name": "Shifted",
              "values": [
                "5",
                "5",
                "4",
                "6",
                "1",
                "3"
              ],
              "highlightIndices": [
                0,
                1
              ]
            }
          ],
          "annotations": [
            "shift > key"
          ]
        }
      },
      {
        "title": "Insert key",
        "description": "Place the key at its correct position among the sorted prefix.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted prefix",
              "values": [
                "2",
                "5",
                "4",
                "6",
                "1",
                "3"
              ],
              "highlightIndices": [
                0,
                1
              ]
            }
          ],
          "annotations": [
            "prefix sorted"
          ]
        }
      }
    ]
  },
  {
    "id": "selection_sort",
    "name": "Selection Sort",
    "category": "Search & Sort",
    "difficulty": "Beginner",
    "description": "Selection sort repeatedly selects the minimum remaining element and swaps it into place, shrinking the unsorted region.",
    "tags": [
      "sorting",
      "in-place"
    ],
    "complexity": {
      "best": "O(n^2)",
      "average": "O(n^2)",
      "worst": "O(n^2)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n",
      "java": "\npublic void selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        int tmp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = tmp;\n    }\n}\n",
      "cpp": "\nvoid selection_sort(std::vector<int>& arr) {\n    for (std::size_t i = 0; i < arr.size() - 1; ++i) {\n        std::size_t min_index = i;\n        for (std::size_t j = i + 1; j < arr.size(); ++j) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        std::swap(arr[i], arr[min_index]);\n    }\n}\n",
      "csharp": "\npublic void SelectionSort(int[] arr) {\n    for (int i = 0; i < arr.Length - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < arr.Length; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        (arr[i], arr[minIndex]) = (arr[minIndex], arr[i]);\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Find current minimum",
        "description": "Scan the unsorted suffix to locate the smallest element and record its index.",
        "frame": {
          "arrays": [
            {
              "name": "Scan",
              "values": [
                "5",
                "2",
                "4",
                "6",
                "1",
                "3"
              ],
              "highlightIndices": [
                0,
                4
              ]
            }
          ],
          "annotations": [
            "min_index = 4"
          ]
        }
      },
      {
        "title": "Swap into sorted prefix",
        "description": "Swap the minimum value with the first unsorted position to grow the prefix.",
        "frame": {
          "arrays": [
            {
              "name": "After swap",
              "values": [
                "1",
                "2",
                "4",
                "6",
                "5",
                "3"
              ],
              "highlightIndices": [
                0
              ]
            }
          ],
          "annotations": [
            "prefix grows"
          ]
        }
      },
      {
        "title": "Repeat for remaining elements",
        "description": "Continue scanning and swapping until the entire array is sorted.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted result",
              "values": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "6"
              ],
              "highlightIndices": [
                0,
                5
              ]
            }
          ],
          "annotations": [
            "all sorted"
          ]
        }
      }
    ]
  },
  {
    "id": "bubble_sort",
    "name": "Bubble Sort",
    "category": "Search & Sort",
    "difficulty": "Beginner",
    "description": "Bubble sort repeatedly swaps adjacent out-of-order elements, bubbling the largest value to the end on each pass.",
    "tags": [
      "sorting",
      "stable",
      "educational"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n^2)",
      "worst": "O(n^2)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n",
      "java": "\npublic void bubbleSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        boolean swapped = False;\n        for (int j = 0; j < arr.length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int tmp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n                swapped = True;\n            }\n        }\n        if (!swapped) {\n            break;\n        }\n    }\n}\n",
      "cpp": "\nvoid bubble_sort(std::vector<int>& arr) {\n    for (std::size_t i = 0; i < arr.size(); ++i) {\n        bool swapped = False;\n        for (std::size_t j = 0; j + 1 < arr.size() - i; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n                swapped = True;\n            }\n        }\n        if (!swapped) break;\n    }\n}\n",
      "csharp": "\npublic void BubbleSort(int[] arr) {\n    for (int i = 0; i < arr.Length; i++) {\n        bool swapped = False;\n        for (int j = 0; j < arr.Length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\n                swapped = True;\n            }\n        }\n        if (!swapped) {\n            break;\n        }\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Compare adjacent elements",
        "description": "Walk the array, swapping adjacent values if they are out of order to push large elements toward the end.",
        "frame": {
          "arrays": [
            {
              "name": "Pass",
              "values": [
                "5",
                "1",
                "4",
                "2",
                "8"
              ],
              "highlightIndices": [
                0,
                1
              ]
            }
          ],
          "annotations": [
            "swap if arr[j] > arr[j+1]"
          ]
        }
      },
      {
        "title": "Largest element bubbles up",
        "description": "After first pass, the largest element settles at the end of the array.",
        "frame": {
          "arrays": [
            {
              "name": "Array",
              "values": [
                "1",
                "4",
                "2",
                "5",
                "8"
              ],
              "highlightIndices": [
                4
              ]
            }
          ],
          "annotations": [
            "largest at end"
          ]
        }
      },
      {
        "title": "Repeat passes",
        "description": "Continue passes, each time reducing the range until no swaps are required.",
        "frame": {
          "arrays": [
            {
              "name": "Sorted",
              "values": [
                "1",
                "2",
                "4",
                "5",
                "8"
              ],
              "highlightIndices": [
                0,
                4
              ]
            }
          ],
          "annotations": [
            "fully sorted"
          ]
        }
      }
    ]
  },
  {
    "id": "breadth_first_search",
    "name": "Breadth-First Search",
    "category": "Graph Theory",
    "difficulty": "Beginner",
    "description": "Breadth-first search explores graph vertices in layers using a queue, guaranteeing the shortest path in unweighted graphs.",
    "tags": [
      "graph traversal",
      "queue",
      "shortest path"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set([start])\n    order = []\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return order\n",
      "java": "\npublic List<Integer> bfs(Map<Integer, List<Integer>> graph, int start) {\n    Set<Integer> visited = new HashSet<>();\n    List<Integer> order = new ArrayList<>();\n    Queue<Integer> queue = new ArrayDeque<>();\n    visited.add(start);\n    queue.offer(start);\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        order.add(node);\n        for (int neighbor : graph.getOrDefault(node, List.of())) {\n            if (visited.add(neighbor)) {\n                queue.offer(neighbor);\n            }\n        }\n    }\n    return order;\n}\n",
      "cpp": "\nstd::vector<int> bfs(const std::unordered_map<int, std::vector<int>>& graph, int start) {\n    std::unordered_set<int> visited;\n    std::vector<int> order;\n    std::queue<int> queue;\n    visited.insert(start);\n    queue.push(start);\n    while (!queue.empty()) {\n        int node = queue.front();\n        queue.pop();\n        order.push_back(node);\n        auto it = graph.find(node);\n        if (it != graph.end()) {\n            for (int neighbor : it->second) {\n                if (!visited.count(neighbor)) {\n                    visited.insert(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n    return order;\n}\n",
      "csharp": "\npublic IList<int> Bfs(Dictionary<int, IList<int>> graph, int start) {\n    var visited = new HashSet<int> { start };\n    var order = new List<int>();\n    var queue = new Queue<int>();\n    queue.Enqueue(start);\n    while (queue.Count > 0) {\n        int node = queue.Dequeue();\n        order.Add(node);\n        if (!graph.TryGetValue(node, out var neighbors)) continue;\n        foreach (var neighbor in neighbors) {\n            if (visited.Add(neighbor)) {\n                queue.Enqueue(neighbor);\n            }\n        }\n    }\n    return order;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize queue",
        "description": "Start from the source node, mark it visited, and enqueue it.",
        "frame": {
          "nodes": [
            {
              "id": "s",
              "label": "S",
              "x": 0.5,
              "y": 0.2,
              "highlight": true
            }
          ],
          "annotations": [
            "queue = [S]"
          ]
        }
      },
      {
        "title": "Expand frontier",
        "description": "Dequeue nodes one by one, enqueueing unseen neighbors to visit level by level.",
        "frame": {
          "nodes": [
            {
              "id": "s",
              "label": "S",
              "x": 0.5,
              "y": 0.2
            },
            {
              "id": "a",
              "label": "A",
              "x": 0.3,
              "y": 0.45,
              "highlight": true
            },
            {
              "id": "b",
              "label": "B",
              "x": 0.7,
              "y": 0.45,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "s",
              "to": "a",
              "directed": false,
              "highlight": true
            },
            {
              "from": "s",
              "to": "b",
              "directed": false,
              "highlight": true
            }
          ],
          "annotations": [
            "visit neighbors"
          ]
        }
      },
      {
        "title": "Layer traversal",
        "description": "Continue level order traversal until all reachable vertices are explored.",
        "frame": {
          "annotations": [
            "queue empty -> done"
          ]
        }
      }
    ]
  },
  {
    "id": "depth_first_search",
    "name": "Depth-First Search",
    "category": "Graph Theory",
    "difficulty": "Beginner",
    "description": "Depth-first search explores as far as possible down each branch before backtracking, naturally implemented with recursion or a stack.",
    "tags": [
      "graph traversal",
      "recursion",
      "stack"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\ndef dfs(graph, start, visited=None, order=None):\n    if visited is None:\n        visited = set()\n    if order is None:\n        order = []\n    visited.add(start)\n    order.append(start)\n    for neighbor in graph.get(start, []):\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited, order)\n    return order\n",
      "java": "\npublic List<Integer> dfs(Map<Integer, List<Integer>> graph, int start) {\n    List<Integer> order = new ArrayList<>();\n    Set<Integer> visited = new HashSet<>();\n    dfsRecursive(graph, start, visited, order);\n    return order;\n}\n\nprivate void dfsRecursive(Map<Integer, List<Integer>> graph, int node,\n                          Set<Integer> visited, List<Integer> order) {\n    visited.add(node);\n    order.add(node);\n    for (int neighbor : graph.getOrDefault(node, List.of())) {\n        if (!visited.contains(neighbor)) {\n            dfsRecursive(graph, neighbor, visited, order);\n        }\n    }\n}\n",
      "cpp": "\nvoid dfs_recursive(const std::unordered_map<int, std::vector<int>>& graph,\n                   int node,\n                   std::unordered_set<int>& visited,\n                   std::vector<int>& order) {\n    visited.insert(node);\n    order.push_back(node);\n    auto it = graph.find(node);\n    if (it != graph.end()) {\n        for (int neighbor : it->second) {\n            if (!visited.count(neighbor)) {\n                dfs_recursive(graph, neighbor, visited, order);\n            }\n        }\n    }\n}\n\nstd::vector<int> dfs(const std::unordered_map<int, std::vector<int>>& graph, int start) {\n    std::unordered_set<int> visited;\n    std::vector<int> order;\n    dfs_recursive(graph, start, visited, order);\n    return order;\n}\n",
      "csharp": "\npublic IList<int> Dfs(Dictionary<int, IList<int>> graph, int start) {\n    var visited = new HashSet<int>();\n    var order = new List<int>();\n    void Visit(int node) {\n        visited.Add(node);\n        order.Add(node);\n        if (!graph.TryGetValue(node, out var neighbors)) return;\n        foreach (var neighbor in neighbors) {\n            if (!visited.Contains(neighbor)) {\n                Visit(neighbor);\n            }\n        }\n    }\n    Visit(start);\n    return order;\n}\n"
    },
    "steps": [
      {
        "title": "Descend recursively",
        "description": "From the root node, recursively explore deeper unvisited neighbors.",
        "frame": {
          "annotations": [
            "stack depth increases"
          ]
        }
      },
      {
        "title": "Backtrack",
        "description": "When a branch is exhausted, backtrack to explore alternative paths, unwinding recursion.",
        "frame": {
          "annotations": [
            "return from call stack"
          ]
        }
      },
      {
        "title": "Complete traversal",
        "description": "All reachable vertices are visited once the recursion stack empties.",
        "frame": {
          "annotations": [
            "visited contains all reachable nodes"
          ]
        }
      }
    ]
  },
  {
    "id": "dijkstra",
    "name": "Dijkstra's Shortest Path",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Dijkstra's algorithm computes the shortest path from a source in a graph with non-negative edge weights using a priority queue.",
    "tags": [
      "shortest path",
      "priority queue",
      "greedy"
    ],
    "complexity": {
      "best": "O(E + V log V)",
      "average": "O(E log V)",
      "worst": "O(E log V)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        dist, node = heapq.heappop(pq)\n        if dist > distances[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            new_dist = dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    return distances\n",
      "java": "\npublic Map<Integer, Integer> dijkstra(Map<Integer, List<int[]>> graph, int start) {\n    Map<Integer, Integer> dist = new HashMap<>();\n    for (int node : graph.keySet()) {\n        dist.put(node, Integer.MAX_VALUE);\n    }\n    dist.put(start, 0);\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    pq.offer(new int[]{0, start});\n    while (!pq.isEmpty()) {\n        int[] current = pq.poll();\n        int distance = current[0];\n        int node = current[1];\n        if (distance > dist.get(node)) continue;\n        for (int[] edge : graph.getOrDefault(node, List.of())) {\n            int neighbor = edge[0];\n            int weight = edge[1];\n            int newDist = distance + weight;\n            if (newDist < dist.getOrDefault(neighbor, Integer.MAX_VALUE)) {\n                dist.put(neighbor, newDist);\n                pq.offer(new int[]{newDist, neighbor});\n            }\n        }\n    }\n    return dist;\n}\n",
      "cpp": "\nstd::unordered_map<int, int> dijkstra(\n    const std::unordered_map<int, std::vector<std::pair<int, int>>>& graph, int start) {\n    const int INF = std::numeric_limits<int>::max();\n    std::unordered_map<int, int> dist;\n    for (const auto& [node, _] : graph) {\n        dist[node] = INF;\n    }\n    dist[start] = 0;\n    using State = std::pair<int, int>;\n    std::priority_queue<State, std::vector<State>, std::greater<State>> pq;\n    pq.emplace(0, start);\n    while (!pq.empty()) {\n        auto [d, node] = pq.top();\n        pq.pop();\n        if (d > dist[node]) continue;\n        auto it = graph.find(node);\n        if (it != graph.end()) {\n            for (const auto& [neighbor, weight] : it->second) {\n                int new_dist = d + weight;\n                if (new_dist < dist[neighbor]) {\n                    dist[neighbor] = new_dist;\n                    pq.emplace(new_dist, neighbor);\n                }\n            }\n        }\n    }\n    return dist;\n}\n",
      "csharp": "\npublic Dictionary<int, int> Dijkstra(Dictionary<int, IList<(int neighbor, int weight)>> graph, int start) {\n    const int INF = int.MaxValue;\n    var dist = graph.Keys.ToDictionary(node => node, _ => INF);\n    dist[start] = 0;\n    var pq = new PriorityQueue<int, int>();\n    pq.Enqueue(start, 0);\n    while (pq.Count > 0) {\n        pq.TryDequeue(out var node, out var distance);\n        if (distance > dist[node]) continue;\n        if (!graph.TryGetValue(node, out var neighbors)) continue;\n        foreach (var (neighbor, weight) in neighbors) {\n            int newDist = distance + weight;\n            if (newDist < dist[neighbor]) {\n                dist[neighbor] = newDist;\n                pq.Enqueue(neighbor, newDist);\n            }\n        }\n    }\n    return dist;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize priority queue",
        "description": "Set the source distance to zero and push it onto the priority queue.",
        "frame": {
          "annotations": [
            "pq = [(0, source)]"
          ]
        }
      },
      {
        "title": "Relax edges",
        "description": "Pop the closest node, relax outgoing edges, and update neighbor distances when shorter paths are found.",
        "frame": {
          "annotations": [
            "distance updates propagate"
          ]
        }
      },
      {
        "title": "Finalize distances",
        "description": "When the queue empties, the shortest distance to every reachable node is determined.",
        "frame": {
          "annotations": [
            "queue empty -> done"
          ]
        }
      }
    ]
  },
  {
    "id": "bellman_ford",
    "name": "Bellman Ford Shortest Path",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Bellman\u00e2\u20ac\u201cFord relaxes edges repeatedly to compute shortest paths in graphs that may contain negative weights, also detecting negative cycles.",
    "tags": [
      "shortest path",
      "dynamic programming",
      "negative weights"
    ],
    "complexity": {
      "best": "O(VE)",
      "average": "O(VE)",
      "worst": "O(VE)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\ndef bellman_ford(vertices, edges, start):\n    distance = {v: float('inf') for v in vertices}\n    distance[start] = 0\n    for _ in range(len(vertices) - 1):\n        updated = False\n        for u, v, w in edges:\n            if distance[u] + w < distance[v]:\n                distance[v] = distance[u] + w\n                updated = True\n        if not updated:\n            break\n    for u, v, w in edges:\n        if distance[u] + w < distance[v]:\n            raise ValueError('Negative cycle detected')\n    return distance\n",
      "java": "\npublic Map<Integer, Integer> bellmanFord(Set<Integer> vertices, List<int[]> edges, int start) {\n    Map<Integer, Integer> distance = new HashMap<>();\n    for (int v : vertices) {\n        distance.put(v, Integer.MAX_VALUE);\n    }\n    distance.put(start, 0);\n    for (int i = 0; i < vertices.size() - 1; i++) {\n        boolean updated = False;\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            if (distance.get(u) != Integer.MAX_VALUE && distance.get(u) + w < distance.get(v)) {\n                distance.put(v, distance.get(u) + w);\n                updated = True;\n            }\n        }\n        if (!updated) break;\n    }\n    for (int[] edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        if (distance.get(u) != Integer.MAX_VALUE && distance.get(u) + w < distance.get(v)) {\n            throw new IllegalStateException(\"Negative cycle detected\");\n        }\n    }\n    return distance;\n}\n",
      "cpp": "\nstd::unordered_map<int, int> bellman_ford(\n    const std::unordered_set<int>& vertices,\n    const std::vector<std::tuple<int, int, int>>& edges,\n    int start) {\n    const int INF = std::numeric_limits<int>::max();\n    std::unordered_map<int, int> dist;\n    for (int v : vertices) {\n        dist[v] = INF;\n    }\n    dist[start] = 0;\n    for (std::size_t i = 0; i < vertices.size() - 1; ++i) {\n        bool updated = False;\n        for (const auto& [u, v, w] : edges) {\n            if (dist[u] != INF && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                updated = True;\n            }\n        }\n        if (!updated) break;\n    }\n    for (const auto& [u, v, w] : edges) {\n        if (dist[u] != INF && dist[u] + w < dist[v]) {\n            throw std::runtime_error(\"Negative cycle detected\");\n        }\n    }\n    return dist;\n}\n",
      "csharp": "\npublic Dictionary<int, int> BellmanFord(IEnumerable<int> vertices, IEnumerable<(int u, int v, int w)> edges, int start) {\n    const int INF = int.MaxValue;\n    var distance = vertices.ToDictionary(v => v, _ => INF);\n    distance[start] = 0;\n    int vertexCount = distance.Count;\n    for (int i = 0; i < vertexCount - 1; i++) {\n        bool updated = False;\n        foreach (var (u, v, w) in edges) {\n            if (distance[u] != INF && distance[u] + w < distance[v]) {\n                distance[v] = distance[u] + w;\n                updated = True;\n            }\n        }\n        if (!updated) break;\n    }\n    foreach (var (u, v, w) in edges) {\n        if (distance[u] != INF && distance[u] + w < distance[v]) {\n            throw new InvalidOperationException(\"Negative cycle detected\");\n        }\n    }\n    return distance;\n}\n"
    },
    "steps": [
      {
        "title": "Relax edges repeatedly",
        "description": "Perform |V|-1 passes over all edges, relaxing them to propagate shortest distances.",
        "frame": {
          "annotations": [
            "repeat edge relaxation"
          ]
        }
      },
      {
        "title": "Early exit optimization",
        "description": "Stop if a pass completes without updates, indicating convergence.",
        "frame": {
          "annotations": [
            "no updates -> break"
          ]
        }
      },
      {
        "title": "Negative cycle check",
        "description": "A final pass revealing a shorter path indicates a reachable negative-weight cycle.",
        "frame": {
          "annotations": [
            "detect negative cycle"
          ]
        }
      }
    ]
  },
  {
    "id": "floyd_warshall",
    "name": "Floyd-Warshall All-Pairs Shortest Paths",
    "category": "Graph Theory",
    "difficulty": "Advanced",
    "description": "Floyd-Warshall iteratively improves all-pairs shortest paths by considering every vertex as an intermediate connector.",
    "tags": [
      "dynamic programming",
      "all-pairs shortest path"
    ],
    "complexity": {
      "best": "O(V^3)",
      "average": "O(V^3)",
      "worst": "O(V^3)",
      "space": "O(V^2)"
    },
    "codeSnippets": {
      "python": "\ndef floyd_warshall(dist):\n    n = len(dist)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    return dist\n",
      "java": "\npublic int[][] floydWarshall(int[][] dist) {\n    int n = dist.length;\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE\n                        && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n}\n",
      "cpp": "\nvoid floyd_warshall(std::vector<std::vector<int>>& dist) {\n    int n = static_cast<int>(dist.size());\n    const int INF = std::numeric_limits<int>::max();\n    for (int k = 0; k < n; ++k) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dist[i][k] != INF && dist[k][j] != INF &&\n                    dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n",
      "csharp": "\npublic int[,] FloydWarshall(int[,] dist) {\n    int n = dist.GetLength(0);\n    const int INF = int.MaxValue;\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i, k] != INF && dist[k, j] != INF &&\n                    dist[i, k] + dist[k, j] < dist[i, j]) {\n                    dist[i, j] = dist[i, k] + dist[k, j];\n                }\n            }\n        }\n    }\n    return dist;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize matrix",
        "description": "Start with direct edge weights (or infinity) for every pair of vertices.",
        "frame": {
          "annotations": [
            "dist[i][j] = weight(i,j)"
          ]
        }
      },
      {
        "title": "Relax through intermediate",
        "description": "For each vertex k, attempt to improve path i->j by combining i->k and k->j.",
        "frame": {
          "annotations": [
            "if dist[i][k] + dist[k][j] < dist[i][j] update"
          ]
        }
      },
      {
        "title": "All pairs shortest path",
        "description": "After processing all k, the matrix contains minimal path costs between every pair.",
        "frame": {
          "annotations": [
            "dist holds final results"
          ]
        }
      }
    ]
  },
  {
    "id": "prim_mst",
    "name": "Prim's Minimum Spanning Tree",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Prim's algorithm grows a minimum spanning tree by repeatedly adding the lightest edge connecting the tree to a new vertex.",
    "tags": [
      "minimum spanning tree",
      "greedy",
      "priority queue"
    ],
    "complexity": {
      "best": "O(E + V log V)",
      "average": "O(E log V)",
      "worst": "O(E log V)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nimport heapq\n\ndef prim(graph, start=0):\n    visited = set([start])\n    edges = []\n    mst = []\n    for weight, neighbor in graph.get(start, []):\n        heapq.heappush(edges, (weight, start, neighbor))\n    while edges:\n        weight, u, v = heapq.heappop(edges)\n        if v in visited:\n            continue\n        visited.add(v)\n        mst.append((u, v, weight))\n        for next_weight, neighbor in graph.get(v, []):\n            if neighbor not in visited:\n                heapq.heappush(edges, (next_weight, v, neighbor))\n    return mst\n",
      "java": "\npublic List<int[]> prim(Map<Integer, List<int[]>> graph, int start) {\n    Set<Integer> visited = new HashSet<>();\n    List<int[]> mst = new ArrayList<>();\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n    visited.add(start);\n    for (int[] edge : graph.getOrDefault(start, List.of())) {\n        pq.offer(new int[]{edge[1], start, edge[0]});\n    }\n    while (!pq.isEmpty() && mst.size() < graph.size() - 1) {\n        int[] current = pq.poll();\n        int weight = current[0];\n        int from = current[1];\n        int to = current[2];\n        if (!visited.add(to)) {\n            continue;\n        }\n        mst.add(new int[]{from, to, weight});\n        for (int[] edge : graph.getOrDefault(to, List.of())) {\n            if (!visited.contains(edge[0])) {\n                pq.offer(new int[]{edge[1], to, edge[0]});\n            }\n        }\n    }\n    return mst;\n}\n",
      "cpp": "\nstd::vector<std::tuple<int, int, int>> prim(\n    const std::unordered_map<int, std::vector<std::pair<int, int>>>& graph, int start) {\n    using Edge = std::tuple<int, int, int>;\n    std::unordered_set<int> visited;\n    std::vector<Edge> mst;\n    std::priority_queue<Edge, std::vector<Edge>, std::greater<Edge>> pq;\n    visited.insert(start);\n    auto it = graph.find(start);\n    if (it != graph.end()) {\n        for (const auto& [neighbor, weight] : it->second) {\n            pq.emplace(weight, start, neighbor);\n        }\n    }\n    while (!pq.empty() && mst.size() < graph.size() - 1) {\n        auto [weight, from, to] = pq.top();\n        pq.pop();\n        if (visited.count(to)) continue;\n        visited.insert(to);\n        mst.emplace_back(from, to, weight);\n        auto jt = graph.find(to);\n        if (jt != graph.end()) {\n            for (const auto& [neighbor, w] : jt->second) {\n                if (!visited.count(neighbor)) {\n                    pq.emplace(w, to, neighbor);\n                }\n            }\n        }\n    }\n    return mst;\n}\n",
      "csharp": "\npublic IList<(int from, int to, int weight)> Prim(Dictionary<int, IList<(int neighbor, int weight)>> graph, int start = 0) {\n    var visited = new HashSet<int> { start };\n    var mst = new List<(int from, int to, int weight)>();\n    var pq = new PriorityQueue<(int from, int to), int>();\n    if (graph.TryGetValue(start, out var neighbors)) {\n        foreach (var (neighbor, weight) in neighbors) {\n            pq.Enqueue((start, neighbor), weight);\n        }\n    }\n    while (pq.Count > 0 && mst.Count < graph.Count - 1) {\n        pq.TryDequeue(out var edge, out var weight);\n        var (from, to) = edge;\n        if (!visited.Add(to)) continue;\n        mst.Add((from, to, weight));\n        if (!graph.TryGetValue(to, out var nextNeighbors)) continue;\n        foreach (var (neighbor, w) in nextNeighbors) {\n            if (!visited.Contains(neighbor)) {\n                pq.Enqueue((to, neighbor), w);\n            }\n        }\n    }\n    return mst;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize frontier",
        "description": "Choose a start vertex, mark it visited, and push its edges into the priority queue.",
        "frame": {
          "annotations": [
            "visited = {start}",
            "queue <- edges(start)"
          ]
        }
      },
      {
        "title": "Greedy edge selection",
        "description": "Extract the lightest edge leading out of the current tree and add the new vertex.",
        "frame": {
          "annotations": [
            "choose min weight crossing edge"
          ]
        }
      },
      {
        "title": "Complete MST",
        "description": "Repeat until all vertices are included, accumulating the MST edges.",
        "frame": {
          "annotations": [
            "|MST| = |V|-1"
          ]
        }
      }
    ]
  },
  {
    "id": "kruskal_mst",
    "name": "Kruskal's Minimum Spanning Tree",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Kruskal's algorithm sorts edges by weight and selects them greedily, skipping those that would form a cycle using a disjoint set union structure.",
    "tags": [
      "minimum spanning tree",
      "greedy",
      "disjoint set"
    ],
    "complexity": {
      "best": "O(E log E)",
      "average": "O(E log E)",
      "worst": "O(E log E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\ndef kruskal(vertices, edges):\n    parent = {v: v for v in vertices}\n    rank = {v: 0 for v in vertices}\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x == root_y:\n            return False\n        if rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        elif rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        return True\n\n    mst = []\n    for u, v, weight in sorted(edges, key=lambda e: e[2]):\n        if union(u, v):\n            mst.append((u, v, weight))\n            if len(mst) == len(vertices) - 1:\n                break\n    return mst\n",
      "java": "\npublic List<int[]> kruskal(Set<Integer> vertices, List<int[]> edges) {\n    UnionFind uf = new UnionFind(vertices);\n    edges.sort(Comparator.comparingInt(e -> e[2]));\n    List<int[]> mst = new ArrayList<>();\n    for (int[] edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        if (uf.union(u, v)) {\n            mst.add(edge);\n            if (mst.size() == vertices.size() - 1) break;\n        }\n    }\n    return mst;\n}\n\nstatic class UnionFind {\n    private final Map<Integer, Integer> parent = new HashMap<>();\n    private final Map<Integer, Integer> rank = new HashMap<>();\n\n    UnionFind(Set<Integer> vertices) {\n        for (int v : vertices) {\n            parent.put(v, v);\n            rank.put(v, 0);\n        }\n    }\n\n    int find(int x) {\n        if (parent.get(x) != x) {\n            parent.put(x, find(parent.get(x)));\n        }\n        return parent.get(x);\n    }\n\n    boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return False;\n        int rankX = rank.get(rootX);\n        int rankY = rank.get(rootY);\n        if (rankX < rankY) {\n            parent.put(rootX, rootY);\n        } else if (rankX > rankY) {\n            parent.put(rootY, rootX);\n        } else {\n            parent.put(rootY, rootX);\n            rank.put(rootX, rankX + 1);\n        }\n        return True;\n    }\n}\n",
      "cpp": "\nstruct UnionFind {\n    std::unordered_map<int, int> parent;\n    std::unordered_map<int, int> rank;\n    explicit UnionFind(const std::unordered_set<int>& vertices) {\n        for (int v : vertices) {\n            parent[v] = v;\n            rank[v] = 0;\n        }\n    }\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    bool unite(int x, int y) {\n        int rootX = find(x), rootY = find(y);\n        if (rootX == rootY) return False;\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return True;\n    }\n};\n\nstd::vector<std::tuple<int, int, int>> kruskal(\n    const std::unordered_set<int>& vertices,\n    std::vector<std::tuple<int, int, int>> edges) {\n    std::sort(edges.begin(), edges.end(),\n              [](const auto& a, const auto& b) { return std::get<2>(a) < std::get<2>(b); });\n    UnionFind uf(vertices);\n    std::vector<std::tuple<int, int, int>> mst;\n    for (const auto& [u, v, w] : edges) {\n        if (uf.unite(u, v)) {\n            mst.emplace_back(u, v, w);\n            if (mst.size() == vertices.size() - 1) break;\n        }\n    }\n    return mst;\n}\n",
      "csharp": "\npublic IList<(int u, int v, int w)> Kruskal(IEnumerable<int> vertices, IList<(int u, int v, int w)> edges) {\n    var uf = new UnionFind(vertices);\n    var orderedEdges = edges.OrderBy(e => e.w);\n    var mst = new List<(int u, int v, int w)>();\n    foreach (var edge in orderedEdges) {\n        if (uf.Union(edge.u, edge.v)) {\n            mst.Add(edge);\n            if (mst.Count == uf.Count - 1) break;\n        }\n    }\n    return mst;\n}\n\nprivate sealed class UnionFind {\n    private readonly Dictionary<int, int> _parent;\n    private readonly Dictionary<int, int> _rank;\n    public int Count => _parent.Count;\n\n    public UnionFind(IEnumerable<int> vertices) {\n        _parent = new Dictionary<int, int>();\n        _rank = new Dictionary<int, int>();\n        foreach (var v in vertices) {\n            _parent[v] = v;\n            _rank[v] = 0;\n        }\n    }\n\n    private int Find(int x) {\n        if (_parent[x] != x) {\n            _parent[x] = Find(_parent[x]);\n        }\n        return _parent[x];\n    }\n\n    public bool Union(int x, int y) {\n        int rootX = Find(x);\n        int rootY = Find(y);\n        if (rootX == rootY) return False;\n        if (_rank[rootX] < _rank[rootY]) {\n            _parent[rootX] = rootY;\n        } else if (_rank[rootX] > _rank[rootY]) {\n            _parent[rootY] = rootX;\n        } else {\n            _parent[rootY] = rootX;\n            _rank[rootX]++;\n        }\n        return True;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Sort edges by weight",
        "description": "Process edges ascending by weight to support greedy selection.",
        "frame": {
          "annotations": [
            "sort edges"
          ]
        }
      },
      {
        "title": "Union-find check",
        "description": "Only accept edges that connect two different components, avoiding cycles.",
        "frame": {
          "annotations": [
            "if find(u) != find(v)"
          ]
        }
      },
      {
        "title": "Assemble MST",
        "description": "Stop once |V|-1 edges have been chosen; these form the minimum spanning tree.",
        "frame": {
          "annotations": [
            "mst complete"
          ]
        }
      }
    ]
  },
  {
    "id": "topological_sort_dfs",
    "name": "Topological Sort (DFS)",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "A depth-first traversal on a directed acyclic graph that records nodes after exploring descendants yields a topological ordering.",
    "tags": [
      "dag",
      "ordering",
      "dfs"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\ndef topo_sort_dfs(graph):\n    visited = set()\n    order = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                dfs(neighbor)\n        order.append(node)\n\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n    order.reverse()\n    return order\n",
      "java": "\npublic List<Integer> topoSortDfs(Map<Integer, List<Integer>> graph) {\n    Set<Integer> visited = new HashSet<>();\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (int node : graph.keySet()) {\n        if (!visited.contains(node)) {\n            dfs(node, graph, visited, stack);\n        }\n    }\n    List<Integer> order = new ArrayList<>();\n    while (!stack.isEmpty()) {\n        order.add(stack.pop());\n    }\n    return order;\n}\n\nprivate void dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited, Deque<Integer> stack) {\n    visited.add(node);\n    for (int neighbor : graph.getOrDefault(node, List.of())) {\n        if (!visited.contains(neighbor)) {\n            dfs(neighbor, graph, visited, stack);\n        }\n    }\n    stack.push(node);\n}\n",
      "cpp": "\nvoid topo_dfs_util(int node,\n                   const std::unordered_map<int, std::vector<int>>& graph,\n                   std::unordered_set<int>& visited,\n                   std::vector<int>& order) {\n    visited.insert(node);\n    auto it = graph.find(node);\n    if (it != graph.end()) {\n        for (int neighbor : it->second) {\n            if (!visited.count(neighbor)) {\n                topo_dfs_util(neighbor, graph, visited, order);\n            }\n        }\n    }\n    order.push_back(node);\n}\n\nstd::vector<int> topo_sort_dfs(const std::unordered_map<int, std::vector<int>>& graph) {\n    std::unordered_set<int> visited;\n    std::vector<int> order;\n    for (const auto& [node, _] : graph) {\n        if (!visited.count(node)) {\n            topo_dfs_util(node, graph, visited, order);\n        }\n    }\n    std::reverse(order.begin(), order.end());\n    return order;\n}\n",
      "csharp": "\npublic IList<int> TopologicalSortDfs(Dictionary<int, IList<int>> graph) {\n    var visited = new HashSet<int>();\n    var order = new List<int>();\n    void Visit(int node) {\n        visited.Add(node);\n        if (graph.TryGetValue(node, out var neighbors)) {\n            foreach (var neighbor in neighbors) {\n                if (!visited.Contains(neighbor)) {\n                    Visit(neighbor);\n                }\n            }\n        }\n        order.Add(node);\n    }\n    foreach (var node in graph.Keys) {\n        if (!visited.Contains(node)) {\n            Visit(node);\n        }\n    }\n    order.Reverse();\n    return order;\n}\n"
    },
    "steps": [
      {
        "title": "Depth-first traversal",
        "description": "Explore each vertex recursively to ensure dependencies are processed first.",
        "frame": {
          "annotations": [
            "dfs in DAG"
          ]
        }
      },
      {
        "title": "Post-order push",
        "description": "Record vertices after exploring their outgoing edges to capture finishing order.",
        "frame": {
          "annotations": [
            "push after recursion"
          ]
        }
      },
      {
        "title": "Reverse list",
        "description": "Reverse the finishing order to obtain the topological ordering.",
        "frame": {
          "annotations": [
            "reverse to get topo order"
          ]
        }
      }
    ]
  },
  {
    "id": "kahn_topological_sort",
    "name": "Kahn's Topological Sort",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Kahn's algorithm repeatedly removes vertices with zero indegree, constructing a topological ordering and detecting cycles when they remain.",
    "tags": [
      "dag",
      "queue",
      "indegree"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nfrom collections import deque\n\ndef kahn_topo(graph):\n    indegree = {node: 0 for node in graph}\n    for neighbors in graph.values():\n        for neighbor in neighbors:\n            indegree[neighbor] = indegree.get(neighbor, 0) + 1\n    queue = deque([node for node, deg in indegree.items() if deg == 0])\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph.get(node, []):\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    if len(order) != len(indegree):\n        raise ValueError('Graph has a cycle')\n    return order\n",
      "java": "\npublic List<Integer> kahnTopologicalSort(Map<Integer, List<Integer>> graph) {\n    Map<Integer, Integer> indegree = new HashMap<>();\n    for (int node : graph.keySet()) {\n        indegree.putIfAbsent(node, 0);\n        for (int neighbor : graph.get(node)) {\n            indegree.merge(neighbor, 1, Integer::sum);\n        }\n    }\n    Queue<Integer> queue = new ArrayDeque<>();\n    indegree.forEach((node, deg) -> {\n        if (deg == 0) queue.offer(node);\n    });\n    List<Integer> order = new ArrayList<>();\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        order.add(node);\n        for (int neighbor : graph.getOrDefault(node, List.of())) {\n            indegree.computeIfPresent(neighbor, (k, v) -> v - 1);\n            if (indegree.get(neighbor) == 0) {\n                queue.offer(neighbor);\n            }\n        }\n    }\n    if (order.size() != indegree.size()) {\n        throw new IllegalStateException(\"Graph has a cycle\");\n    }\n    return order;\n}\n",
      "cpp": "\nstd::vector<int> kahn_topological_sort(const std::unordered_map<int, std::vector<int>>& graph) {\n    std::unordered_map<int, int> indegree;\n    for (const auto& [node, neighbors] : graph) {\n        indegree.try_emplace(node, 0);\n        for (int neighbor : neighbors) {\n            indegree[neighbor]++;\n        }\n    }\n    std::queue<int> queue;\n    for (const auto& [node, deg] : indegree) {\n        if (deg == 0) queue.push(node);\n    }\n    std::vector<int> order;\n    while (!queue.empty()) {\n        int node = queue.front();\n        queue.pop();\n        order.push_back(node);\n        auto it = graph.find(node);\n        if (it != graph.end()) {\n            for (int neighbor : it->second) {\n                if (--indegree[neighbor] == 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n    if (order.size() != indegree.size()) {\n        throw std::runtime_error(\"Graph has a cycle\");\n    }\n    return order;\n}\n",
      "csharp": "\npublic IList<int> KahnTopologicalSort(Dictionary<int, IList<int>> graph) {\n    var indegree = new Dictionary<int, int>();\n    foreach (var (node, neighbors) in graph) {\n        indegree.TryAdd(node, 0);\n        foreach (var neighbor in neighbors) {\n            indegree.TryGetValue(neighbor, out var deg);\n            indegree[neighbor] = deg + 1;\n        }\n    }\n    var queue = new Queue<int>(indegree.Where(kv => kv.Value == 0).Select(kv => kv.Key));\n    var order = new List<int>();\n    while (queue.Count > 0) {\n        var node = queue.Dequeue();\n        order.Add(node);\n        if (!graph.TryGetValue(node, out var neighbors)) continue;\n        foreach (var neighbor in neighbors) {\n            indegree[neighbor]--;\n            if (indegree[neighbor] == 0) {\n                queue.Enqueue(neighbor);\n            }\n        }\n    }\n    if (order.Count != indegree.Count) {\n        throw new InvalidOperationException(\"Graph has a cycle\");\n    }\n    return order;\n}\n"
    },
    "steps": [
      {
        "title": "Compute indegrees",
        "description": "Count incoming edges for every vertex to find those with zero indegree.",
        "frame": {
          "annotations": [
            "indegree map"
          ]
        }
      },
      {
        "title": "Process zero-indegree nodes",
        "description": "Remove nodes with indegree zero, append them to the order, and decrement indegrees of neighbors.",
        "frame": {
          "annotations": [
            "queue of zero indegree nodes"
          ]
        }
      },
      {
        "title": "Cycle detection",
        "description": "If vertices remain with indegree > 0, a cycle exists and no topological order is possible.",
        "frame": {
          "annotations": [
            "check residual indegree"
          ]
        }
      }
    ]
  },
  {
    "id": "tarjan_scc",
    "name": "Tarjan's Strongly Connected Components",
    "category": "Graph Theory",
    "difficulty": "Advanced",
    "description": "Tarjan's algorithm discovers strongly connected components in a directed graph by tracking discovery indices, low-link values, and a recursion stack.",
    "tags": [
      "strongly connected components",
      "dfs",
      "stack"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\ndef tarjan_scc(graph):\n    index = 0\n    stack = []\n    on_stack = set()\n    indices = {}\n    lowlink = {}\n    components = []\n\n    def strongconnect(node):\n        nonlocal index\n        indices[node] = index\n        lowlink[node] = index\n        index += 1\n        stack.append(node)\n        on_stack.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in indices:\n                strongconnect(neighbor)\n                lowlink[node] = min(lowlink[node], lowlink[neighbor])\n            elif neighbor in on_stack:\n                lowlink[node] = min(lowlink[node], indices[neighbor])\n\n        if lowlink[node] == indices[node]:\n            component = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                component.append(w)\n                if w == node:\n                    break\n            components.append(component)\n\n    for node in graph:\n        if node not in indices:\n            strongconnect(node)\n    return components\n",
      "java": "\npublic List<List<Integer>> tarjanScc(Map<Integer, List<Integer>> graph) {\n    Map<Integer, Integer> indexMap = new HashMap<>();\n    Map<Integer, Integer> lowLink = new HashMap<>();\n    Deque<Integer> stack = new ArrayDeque<>();\n    Set<Integer> onStack = new HashSet<>();\n    List<List<Integer>> components = new ArrayList<>();\n    AtomicInteger index = new AtomicInteger(0);\n\n    for (int node : graph.keySet()) {\n        if (!indexMap.containsKey(node)) {\n            strongConnect(node, graph, indexMap, lowLink, stack, onStack, components, index);\n        }\n    }\n    return components;\n}\n\nprivate void strongConnect(int node,\n                           Map<Integer, List<Integer>> graph,\n                           Map<Integer, Integer> indexMap,\n                           Map<Integer, Integer> lowLink,\n                           Deque<Integer> stack,\n                           Set<Integer> onStack,\n                           List<List<Integer>> components,\n                           AtomicInteger index) {\n    indexMap.put(node, index.get());\n    lowLink.put(node, index.getAndIncrement());\n    stack.push(node);\n    onStack.add(node);\n\n    for (int neighbor : graph.getOrDefault(node, List.of())) {\n        if (!indexMap.containsKey(neighbor)) {\n            strongConnect(neighbor, graph, indexMap, lowLink, stack, onStack, components, index);\n            lowLink.put(node, Math.min(lowLink.get(node), lowLink.get(neighbor)));\n        } else if (onStack.contains(neighbor)) {\n            lowLink.put(node, Math.min(lowLink.get(node), indexMap.get(neighbor)));\n        }\n    }\n\n    if (lowLink.get(node).equals(indexMap.get(node))) {\n        List<Integer> component = new ArrayList<>();\n        int w;\n        do {\n            w = stack.pop();\n            onStack.remove(w);\n            component.add(w);\n        } while (w != node);\n        components.add(component);\n    }\n}\n",
      "cpp": "\nclass TarjanSCC {\n  std::unordered_map<int, int> index;\n  std::unordered_map<int, int> lowlink;\n  std::vector<int> stack;\n  std::unordered_set<int> on_stack;\n  std::vector<std::vector<int>> components;\n  int current_index = 0;\n\n  void strong_connect(int node,\n                      const std::unordered_map<int, std::vector<int>>& graph) {\n    index[node] = current_index;\n    lowlink[node] = current_index;\n    current_index++;\n    stack.push_back(node);\n    on_stack.insert(node);\n\n    auto it = graph.find(node);\n    if (it != graph.end()) {\n      for (int neighbor : it->second) {\n        if (!index.count(neighbor)) {\n          strong_connect(neighbor, graph);\n          lowlink[node] = std::min(lowlink[node], lowlink[neighbor]);\n        } else if (on_stack.count(neighbor)) {\n          lowlink[node] = std::min(lowlink[node], index[neighbor]);\n        }\n      }\n    }\n\n    if (lowlink[node] == index[node]) {\n      std::vector<int> component;\n      while (True) {\n        int w = stack.back();\n        stack.pop_back();\n        on_stack.erase(w);\n        component.push_back(w);\n        if (w == node) break;\n      }\n      components.push_back(component);\n    }\n  }\n\npublic:\n  std::vector<std::vector<int>> operator()(const std::unordered_map<int, std::vector<int>>& graph) {\n    for (const auto& [node, _] : graph) {\n      if (!index.count(node)) {\n        strong_connect(node, graph);\n      }\n    }\n    return components;\n  }\n};\n",
      "csharp": "\npublic IList<IList<int>> Tarjan(Dictionary<int, IList<int>> graph) {\n    var index = new Dictionary<int, int>();\n    var lowlink = new Dictionary<int, int>();\n    var stack = new Stack<int>();\n    var onStack = new HashSet<int>();\n    var components = new List<IList<int>>();\n    int currentIndex = 0;\n\n    void StrongConnect(int node) {\n        index[node] = currentIndex;\n        lowlink[node] = currentIndex;\n        currentIndex++;\n        stack.Push(node);\n        onStack.Add(node);\n\n        if (graph.TryGetValue(node, out var neighbors)) {\n            foreach (var neighbor in neighbors) {\n                if (!index.ContainsKey(neighbor)) {\n                    StrongConnect(neighbor);\n                    lowlink[node] = Math.Min(lowlink[node], lowlink[neighbor]);\n                } else if (onStack.Contains(neighbor)) {\n                    lowlink[node] = Math.Min(lowlink[node], index[neighbor]);\n                }\n            }\n        }\n\n        if (lowlink[node] == index[node]) {\n            var component = new List<int>();\n            int w;\n            do {\n                w = stack.Pop();\n                onStack.Remove(w);\n                component.Add(w);\n            } while (w != node);\n            components.Add(component);\n        }\n    }\n\n    foreach (var node in graph.Keys) {\n        if (!index.ContainsKey(node)) {\n            StrongConnect(node);\n        }\n    }\n    return components;\n}\n"
    },
    "steps": [
      {
        "title": "Assign discovery indices",
        "description": "Set index and low-link values when each vertex is first visited.",
        "frame": {
          "annotations": [
            "index[v] = lowlink[v] = counter++"
          ]
        }
      },
      {
        "title": "Update low-link",
        "description": "Propagate low-link values through recursion and edges to nodes on the stack.",
        "frame": {
          "annotations": [
            "lowlink[u] = min(lowlink[u], lowlink[v])"
          ]
        }
      },
      {
        "title": "Pop component",
        "description": "When a root vertex is found, pop the recursion stack to retrieve its strongly connected component.",
        "frame": {
          "annotations": [
            "stack unwind creates SCC"
          ]
        }
      }
    ]
  },
  {
    "id": "kosaraju_scc",
    "name": "Kosaraju's Strongly Connected Components",
    "category": "Graph Theory",
    "difficulty": "Intermediate",
    "description": "Kosaraju's algorithm runs DFS on the original graph to capture finishing order, then traverses the reversed graph to collect strongly connected components.",
    "tags": [
      "strongly connected components",
      "dfs"
    ],
    "complexity": {
      "best": "O(V + E)",
      "average": "O(V + E)",
      "worst": "O(V + E)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nfrom collections import defaultdict\n\ndef kosaraju(graph):\n    visited = set()\n    order = []\n\n    def dfs1(node):\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                dfs1(neighbor)\n        order.append(node)\n\n    for node in graph:\n        if node not in visited:\n            dfs1(node)\n\n    reversed_graph = defaultdict(list)\n    for u, neighbors in graph.items():\n        for v in neighbors:\n            reversed_graph[v].append(u)\n\n    visited.clear()\n    components = []\n\n    def dfs2(node, component):\n        visited.add(node)\n        component.append(node)\n        for neighbor in reversed_graph.get(node, []):\n            if neighbor not in visited:\n                dfs2(neighbor, component)\n\n    for node in reversed(order):\n        if node not in visited:\n            component = []\n            dfs2(node, component)\n            components.append(component)\n    return components\n",
      "java": "\npublic List<List<Integer>> kosaraju(Map<Integer, List<Integer>> graph) {\n    Set<Integer> visited = new HashSet<>();\n    Deque<Integer> order = new ArrayDeque<>();\n    for (int node : graph.keySet()) {\n        if (!visited.contains(node)) {\n            dfs1(node, graph, visited, order);\n        }\n    }\n    Map<Integer, List<Integer>> reversed = new HashMap<>();\n    graph.forEach((u, neighbors) -> {\n        for (int v : neighbors) {\n            reversed.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n        }\n    });\n    visited.clear();\n    List<List<Integer>> components = new ArrayList<>();\n    while (!order.isEmpty()) {\n        int node = order.pop();\n        if (!visited.contains(node)) {\n            List<Integer> component = new ArrayList<>();\n            dfs2(node, reversed, visited, component);\n            components.add(component);\n        }\n    }\n    return components;\n}\n\nprivate void dfs1(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited, Deque<Integer> order) {\n    visited.add(node);\n    for (int neighbor : graph.getOrDefault(node, List.of())) {\n        if (!visited.contains(neighbor)) {\n            dfs1(neighbor, graph, visited, order);\n        }\n    }\n    order.push(node);\n}\n\nprivate void dfs2(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited, List<Integer> component) {\n    visited.add(node);\n    component.add(node);\n    for (int neighbor : graph.getOrDefault(node, List.of())) {\n        if (!visited.contains(neighbor)) {\n            dfs2(neighbor, graph, visited, component);\n        }\n    }\n}\n",
      "cpp": "\nvoid dfs1(int node,\n          const std::unordered_map<int, std::vector<int>>& graph,\n          std::unordered_set<int>& visited,\n          std::stack<int>& order) {\n    visited.insert(node);\n    auto it = graph.find(node);\n    if (it != graph.end()) {\n        for (int neighbor : it->second) {\n            if (!visited.count(neighbor)) {\n                dfs1(neighbor, graph, visited, order);\n            }\n        }\n    }\n    order.push(node);\n}\n\nvoid dfs2(int node,\n          const std::unordered_map<int, std::vector<int>>& graph,\n          std::unordered_set<int>& visited,\n          std::vector<int>& component) {\n    visited.insert(node);\n    component.push_back(node);\n    auto it = graph.find(node);\n    if (it != graph.end()) {\n        for (int neighbor : it->second) {\n            if (!visited.count(neighbor)) {\n                dfs2(neighbor, graph, visited, component);\n            }\n        }\n    }\n}\n\nstd::vector<std::vector<int>> kosaraju(const std::unordered_map<int, std::vector<int>>& graph) {\n    std::unordered_set<int> visited;\n    std::stack<int> order;\n    for (const auto& [node, _] : graph) {\n        if (!visited.count(node)) {\n            dfs1(node, graph, visited, order);\n        }\n    }\n    std::unordered_map<int, std::vector<int>> reversed;\n    for (const auto& [u, neighbors] : graph) {\n        for (int v : neighbors) {\n            reversed[v].push_back(u);\n        }\n    }\n    visited.clear();\n    std::vector<std::vector<int>> components;\n    while (!order.empty()) {\n        int node = order.top();\n        order.pop();\n        if (!visited.count(node)) {\n            std::vector<int> component;\n            dfs2(node, reversed, visited, component);\n            components.push_back(component);\n        }\n    }\n    return components;\n}\n",
      "csharp": "\npublic IList<IList<int>> Kosaraju(Dictionary<int, IList<int>> graph) {\n    var visited = new HashSet<int>();\n    var order = new Stack<int>();\n\n    void Dfs1(int node) {\n        visited.Add(node);\n        if (graph.TryGetValue(node, out var neighbors)) {\n            foreach (var neighbor in neighbors) {\n                if (!visited.Contains(neighbor)) {\n                    Dfs1(neighbor);\n                }\n            }\n        }\n        order.Push(node);\n    }\n\n    foreach (var node in graph.Keys) {\n        if (!visited.Contains(node)) {\n            Dfs1(node);\n        }\n    }\n\n    var reversed = new Dictionary<int, IList<int>>();\n    foreach (var (u, neighbors) in graph) {\n        foreach (var v in neighbors) {\n            if (!reversed.TryGetValue(v, out var list)) {\n                list = new List<int>();\n                reversed[v] = list;\n            }\n            list.Add(u);\n        }\n    }\n\n    visited.Clear();\n    var components = new List<IList<int>>();\n\n    void Dfs2(int node, IList<int> component) {\n        visited.Add(node);\n        component.Add(node);\n        if (!reversed.TryGetValue(node, out var neighbors)) return;\n        foreach (var neighbor in neighbors) {\n            if (!visited.Contains(neighbor)) {\n                Dfs2(neighbor, component);\n            }\n        }\n    }\n\n    while (order.Count > 0) {\n        var node = order.Pop();\n        if (!visited.Contains(node)) {\n            var component = new List<int>();\n            Dfs2(node, component);\n            components.Add(component);\n        }\n    }\n    return components;\n}\n"
    },
    "steps": [
      {
        "title": "First DFS order",
        "description": "Perform DFS on the original graph and push nodes by finishing time.",
        "frame": {
          "annotations": [
            "stack of finish times"
          ]
        }
      },
      {
        "title": "Transpose graph",
        "description": "Reverse all edges to obtain the transpose graph.",
        "frame": {
          "annotations": [
            "reverse edges"
          ]
        }
      },
      {
        "title": "Second DFS for SCCs",
        "description": "Run DFS in order of decreasing finish times on the transpose to collect strongly connected components.",
        "frame": {
          "annotations": [
            "each DFS tree -> SCC"
          ]
        }
      }
    ]
  },
  {
    "id": "disjoint_set_union",
    "name": "Disjoint Set Union (Union-Find)",
    "category": "Data Structures",
    "difficulty": "Beginner",
    "description": "A union-find structure maintains disjoint sets with near-constant time merges and lookups using path compression and union by rank.",
    "tags": [
      "set structure",
      "union-find",
      "path compression"
    ],
    "complexity": {
      "best": "\u00ce\u00b1(n)",
      "average": "\u00ce\u00b1(n)",
      "worst": "\u00ce\u00b1(n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\nclass DisjointSetUnion:\n    def __init__(self, elements):\n        self.parent = {x: x for x in elements}\n        self.rank = {x: 0 for x in elements}\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if self.rank[root_x] < self.rank[root_y]:\n            self.parent[root_x] = root_y\n        elif self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_y] = root_x\n            self.rank[root_x] += 1\n        return True\n",
      "java": "\npublic class DisjointSetUnion {\n    private final int[] parent;\n    private final int[] rank;\n\n    public DisjointSetUnion(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return False;\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return True;\n    }\n}\n",
      "cpp": "\nclass DisjointSetUnion {\n    std::vector<int> parent;\n    std::vector<int> rank;\npublic:\n    explicit DisjointSetUnion(int size) : parent(size), rank(size, 0) {\n        std::iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return False;\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return True;\n    }\n};\n",
      "csharp": "\npublic sealed class DisjointSetUnion {\n    private readonly int[] _parent;\n    private readonly int[] _rank;\n\n    public DisjointSetUnion(int size) {\n        _parent = new int[size];\n        _rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            _parent[i] = i;\n            _rank[i] = 0;\n        }\n    }\n\n    public int Find(int x) {\n        if (_parent[x] != x) {\n            _parent[x] = Find(_parent[x]);\n        }\n        return _parent[x];\n    }\n\n    public bool Union(int x, int y) {\n        int rootX = Find(x);\n        int rootY = Find(y);\n        if (rootX == rootY) return False;\n        if (_rank[rootX] < _rank[rootY]) {\n            _parent[rootX] = rootY;\n        } else if (_rank[rootX] > _rank[rootY]) {\n            _parent[rootY] = rootX;\n        } else {\n            _parent[rootY] = rootX;\n            _rank[rootX]++;\n        }\n        return True;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Initialize singleton sets",
        "description": "Each element is its own parent and rank zero.",
        "frame": {
          "annotations": [
            "parent[i] = i"
          ]
        }
      },
      {
        "title": "Path compression",
        "description": "During find, shortcut parent pointers to the root to flatten the tree.",
        "frame": {
          "annotations": [
            "parent[x] = find(parent[x])"
          ]
        }
      },
      {
        "title": "Union by rank",
        "description": "Attach the tree with lower rank to the higher rank root to keep structures shallow.",
        "frame": {
          "annotations": [
            "merge by rank"
          ]
        }
      }
    ]
  },
  {
    "id": "fenwick_tree",
    "name": "Fenwick Tree (Binary Indexed Tree)",
    "category": "Data Structures",
    "difficulty": "Intermediate",
    "description": "Fenwick trees deliver logarithmic time prefix sums and point updates by storing partial sums indexed via the least significant bit.",
    "tags": [
      "range query",
      "prefix sum",
      "logarithmic"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index, delta):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def prefix_sum(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\n    def range_sum(self, left, right):\n        return self.prefix_sum(right) - self.prefix_sum(left - 1)\n",
      "java": "\npublic class FenwickTree {\n    private final int[] tree;\n\n    public FenwickTree(int size) {\n        tree = new int[size + 1];\n    }\n\n    public void update(int index, int delta) {\n        while (index < tree.length) {\n            tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    public int prefixSum(int index) {\n        int result = 0;\n        while (index > 0) {\n            result += tree[index];\n            index -= index & -index;\n        }\n        return result;\n    }\n\n    public int rangeSum(int left, int right) {\n        return prefixSum(right) - prefixSum(left - 1);\n    }\n}\n",
      "cpp": "\nclass FenwickTree {\n    std::vector<int> tree;\npublic:\n    explicit FenwickTree(int size) : tree(size + 1, 0) {}\n\n    void update(int index, int delta) {\n        while (index < static_cast<int>(tree.size())) {\n            tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    int prefix_sum(int index) const {\n        int result = 0;\n        while (index > 0) {\n            result += tree[index];\n            index -= index & -index;\n        }\n        return result;\n    }\n\n    int range_sum(int left, int right) const {\n        return prefix_sum(right) - prefix_sum(left - 1);\n    }\n};\n",
      "csharp": "\npublic sealed class FenwickTree {\n    private readonly int[] _tree;\n\n    public FenwickTree(int size) {\n        _tree = new int[size + 1];\n    }\n\n    public void Update(int index, int delta) {\n        while (index < _tree.Length) {\n            _tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    public int PrefixSum(int index) {\n        int result = 0;\n        while (index > 0) {\n            result += _tree[index];\n            index -= index & -index;\n        }\n        return result;\n    }\n\n    public int RangeSum(int left, int right) {\n        return PrefixSum(right) - PrefixSum(left - 1);\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Store partial sums",
        "description": "Each index maintains the sum of a range whose length is given by its lowest set bit.",
        "frame": {
          "annotations": [
            "index coverage = index & -index"
          ]
        }
      },
      {
        "title": "Point update",
        "description": "Add delta at a point and propagate changes upward by incrementing index with its LSB.",
        "frame": {
          "annotations": [
            "while index <= n: index += index & -index"
          ]
        }
      },
      {
        "title": "Prefix query",
        "description": "Accumulate contributions while descending by stripping off the lowest set bit.",
        "frame": {
          "annotations": [
            "index -= index & -index"
          ]
        }
      }
    ]
  },
  {
    "id": "segment_tree",
    "name": "Segment Tree",
    "category": "Data Structures",
    "difficulty": "Advanced",
    "description": "Segment trees precompute aggregates for intervals, supporting logarithmic range queries and point updates over arrays.",
    "tags": [
      "range query",
      "tree structure",
      "logarithmic"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.size = 1\n        while self.size < self.n:\n            self.size *= 2\n        self.tree = [0] * (2 * self.size)\n        for i, value in enumerate(data):\n            self.tree[self.size + i] = value\n        for i in range(self.size - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, index, value):\n        pos = self.size + index\n        self.tree[pos] = value\n        pos \n        while pos >= 1:\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n            pos \n\n    def range_sum(self, left, right):\n        left += self.size\n        right += self.size\n        result = 0\n        while left <= right:\n            if left % 2 == 1:\n                result += self.tree[left]\n                left += 1\n            if right % 2 == 0:\n                result += self.tree[right]\n                right -= 1\n            left \n            right \n        return result\n",
      "java": "\npublic class SegmentTree {\n    private final int size;\n    private final int[] tree;\n\n    public SegmentTree(int[] data) {\n        int n = data.length;\n        int pow = 1;\n        while (pow < n) {\n            pow <<= 1;\n        }\n        size = pow;\n        tree = new int[2 * size];\n        System.arraycopy(data, 0, tree, size, n);\n        for (int i = size - 1; i > 0; i--) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    public void update(int index, int value) {\n        int pos = size + index;\n        tree[pos] = value;\n        for (pos >>= 1; pos > 0; pos >>= 1) {\n            tree[pos] = tree[2 * pos] + tree[2 * pos + 1];\n        }\n    }\n\n    public int rangeSum(int left, int right) {\n        int l = size + left;\n        int r = size + right;\n        int result = 0;\n        while (l <= r) {\n            if ((l & 1) == 1) result += tree[l++];\n            if ((r & 1) == 0) result += tree[r--];\n            l >>= 1;\n            r >>= 1;\n        }\n        return result;\n    }\n}\n",
      "cpp": "\nclass SegmentTree {\n    int size;\n    std::vector<int> tree;\npublic:\n    explicit SegmentTree(const std::vector<int>& data) {\n        int n = static_cast<int>(data.size());\n        size = 1;\n        while (size < n) size <<= 1;\n        tree.assign(2 * size, 0);\n        for (int i = 0; i < n; ++i) {\n            tree[size + i] = data[i];\n        }\n        for (int i = size - 1; i > 0; --i) {\n            tree[i] = tree[2 * i] + tree[2 * i + 1];\n        }\n    }\n\n    void update(int index, int value) {\n        int pos = size + index;\n        tree[pos] = value;\n        for (pos >>= 1; pos > 0; pos >>= 1) {\n            tree[pos] = tree[2 * pos] + tree[2 * pos + 1];\n        }\n    }\n\n    int range_sum(int left, int right) const {\n        int l = size + left;\n        int r = size + right;\n        int result = 0;\n        while (l <= r) {\n            if (l & 1) result += tree[l++];\n            if ((r & 1) == 0) result += tree[r--];\n            l >>= 1;\n            r >>= 1;\n        }\n        return result;\n    }\n};\n",
      "csharp": "\npublic sealed class SegmentTree {\n    private readonly int _size;\n    private readonly int[] _tree;\n\n    public SegmentTree(int[] data) {\n        int n = data.Length;\n        int pow = 1;\n        while (pow < n) pow <<= 1;\n        _size = pow;\n        _tree = new int[2 * _size];\n        Array.Copy(data, 0, _tree, _size, n);\n        for (int i = _size - 1; i > 0; i--) {\n            _tree[i] = _tree[2 * i] + _tree[2 * i + 1];\n        }\n    }\n\n    public void Update(int index, int value) {\n        int pos = _size + index;\n        _tree[pos] = value;\n        for (pos >>= 1; pos > 0; pos >>= 1) {\n            _tree[pos] = _tree[2 * pos] + _tree[2 * pos + 1];\n        }\n    }\n\n    public int RangeSum(int left, int right) {\n        int l = _size + left;\n        int r = _size + right;\n        int result = 0;\n        while (l <= r) {\n            if ((l & 1) == 1) result += _tree[l++];\n            if ((r & 1) == 0) result += _tree[r--];\n            l >>= 1;\n            r >>= 1;\n        }\n        return result;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Build tree bottom-up",
        "description": "Populate leaves with array values then compute parent aggregates.",
        "frame": {
          "annotations": [
            "tree[i] = tree[2i] + tree[2i+1]"
          ]
        }
      },
      {
        "title": "Apply point updates",
        "description": "Update a leaf value and recompute ancestors along the path to the root.",
        "frame": {
          "annotations": [
            "update -> parent recompute"
          ]
        }
      },
      {
        "title": "Query range sums",
        "description": "Combine contributions from segments that precisely cover the query interval.",
        "frame": {
          "annotations": [
            "traverse using left/right pointers"
          ]
        }
      }
    ]
  },
  {
    "id": "binary_lifting_lca",
    "name": "Binary Lifting Lowest Common Ancestor",
    "category": "Data Structures",
    "difficulty": "Advanced",
    "description": "Binary lifting precomputes powers-of-two ancestors for each node, enabling logarithmic lowest common ancestor queries on trees.",
    "tags": [
      "tree",
      "lca",
      "preprocessing"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(n log n)"
    },
    "codeSnippets": {
      "python": "\nimport math\n\nclass BinaryLiftingLCA:\n    def __init__(self, tree, root=0):\n        n = len(tree)\n        self.log = math.ceil(math.log2(n + 1))\n        self.up = [[-1] * (self.log + 1) for _ in range(n)]\n        self.depth = [0] * n\n        self._dfs(tree, root, root)\n\n    def _dfs(self, tree, node, parent):\n        self.up[node][0] = parent\n        for k in range(1, self.log + 1):\n            self.up[node][k] = self.up[self.up[node][k - 1]][k - 1]\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            self.depth[neighbor] = self.depth[node] + 1\n            self._dfs(tree, neighbor, node)\n\n    def lca(self, a, b):\n        if self.depth[a] < self.depth[b]:\n            a, b = b, a\n        diff = self.depth[a] - self.depth[b]\n        for k in range(self.log + 1):\n            if diff & (1 << k):\n                a = self.up[a][k]\n        if a == b:\n            return a\n        for k in reversed(range(self.log + 1)):\n            if self.up[a][k] != self.up[b][k]:\n                a = self.up[a][k]\n                b = self.up[b][k]\n        return self.up[a][0]\n",
      "java": "\npublic class BinaryLiftingLca {\n    private final int log;\n    private final int[][] up;\n    private final int[] depth;\n\n    public BinaryLiftingLca(List<List<Integer>> tree, int root) {\n        int n = tree.size();\n        log = (int) Math.ceil(Math.log(n + 1) / Math.log(2));\n        up = new int[n][log + 1];\n        depth = new int[n];\n        dfs(tree, root, root);\n    }\n\n    private void dfs(List<List<Integer>> tree, int node, int parent) {\n        up[node][0] = parent;\n        for (int k = 1; k <= log; k++) {\n            up[node][k] = up[up[node][k - 1]][k - 1];\n        }\n        for (int neighbor : tree.get(node)) {\n            if (neighbor == parent) continue;\n            depth[neighbor] = depth[node] + 1;\n            dfs(tree, neighbor, node);\n        }\n    }\n\n    public int lca(int a, int b) {\n        if (depth[a] < depth[b]) {\n            int tmp = a;\n            a = b;\n            b = tmp;\n        }\n        int diff = depth[a] - depth[b];\n        for (int k = 0; k <= log; k++) {\n            if ((diff & (1 << k)) != 0) {\n                a = up[a][k];\n            }\n        }\n        if (a == b) return a;\n        for (int k = log; k >= 0; k--) {\n            if (up[a][k] != up[b][k]) {\n                a = up[a][k];\n                b = up[b][k];\n            }\n        }\n        return up[a][0];\n    }\n}\n",
      "cpp": "\nclass BinaryLiftingLCA {\n    std::vector<std::vector<int>> up;\n    std::vector<int> depth;\n    int log;\n\n    void dfs(const std::vector<std::vector<int>>& tree, int node, int parent) {\n        up[node][0] = parent;\n        for (int k = 1; k <= log; ++k) {\n            up[node][k] = up[ up[node][k - 1] ][k - 1];\n        }\n        for (int neighbor : tree[node]) {\n            if (neighbor == parent) continue;\n            depth[neighbor] = depth[node] + 1;\n            dfs(tree, neighbor, node);\n        }\n    }\n\npublic:\n    explicit BinaryLiftingLCA(const std::vector<std::vector<int>>& tree, int root = 0) {\n        int n = static_cast<int>(tree.size());\n        log = static_cast<int>(std::ceil(std::log2(n + 1)));\n        up.assign(n, std::vector<int>(log + 1, root));\n        depth.assign(n, 0);\n        dfs(tree, root, root);\n    }\n\n    int lca(int a, int b) const {\n        if (depth[a] < depth[b]) std::swap(a, b);\n        int diff = depth[a] - depth[b];\n        for (int k = 0; k <= log; ++k) {\n            if (diff & (1 << k)) {\n                a = up[a][k];\n            }\n        }\n        if (a == b) return a;\n        for (int k = log; k >= 0; --k) {\n            if (up[a][k] != up[b][k]) {\n                a = up[a][k];\n                b = up[b][k];\n            }\n        }\n        return up[a][0];\n    }\n};\n",
      "csharp": "\npublic sealed class BinaryLiftingLca {\n    private readonly int _log;\n    private readonly int[,] _up;\n    private readonly int[] _depth;\n\n    public BinaryLiftingLca(IList<IList<int>> tree, int root = 0) {\n        int n = tree.Count;\n        _log = (int)Math.Ceiling(Math.Log2(n + 1));\n        _up = new int[n, _log + 1];\n        _depth = new int[n];\n        Dfs(tree, root, root);\n    }\n\n    private void Dfs(IList<IList<int>> tree, int node, int parent) {\n        _up[node, 0] = parent;\n        for (int k = 1; k <= _log; k++) {\n            _up[node, k] = _up[_up[node, k - 1], k - 1];\n        }\n        foreach (var neighbor in tree[node]) {\n            if (neighbor == parent) continue;\n            _depth[neighbor] = _depth[node] + 1;\n            Dfs(tree, neighbor, node);\n        }\n    }\n\n    public int Lca(int a, int b) {\n        if (_depth[a] < _depth[b]) (a, b) = (b, a);\n        int diff = _depth[a] - _depth[b];\n        for (int k = 0; k <= _log; k++) {\n            if ((diff & (1 << k)) != 0) {\n                a = _up[a, k];\n            }\n        }\n        if (a == b) return a;\n        for (int k = _log; k >= 0; k--) {\n            if (_up[a, k] != _up[b, k]) {\n                a = _up[a, k];\n                b = _up[b, k];\n            }\n        }\n        return _up[a, 0];\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Preprocess ancestors",
        "description": "Build an up-table where up[v][k] stores the 2^k-th ancestor of node v.",
        "frame": {
          "annotations": [
            "binary lifting table"
          ]
        }
      },
      {
        "title": "Lift to equal depth",
        "description": "Raise the deeper node by jumping powers of two until depths match.",
        "frame": {
          "annotations": [
            "depth difference lifting"
          ]
        }
      },
      {
        "title": "Lift together",
        "description": "Jump both nodes upward simultaneously until their parents align; that parent is the LCA.",
        "frame": {
          "annotations": [
            "simultaneous lifting"
          ]
        }
      }
    ]
  },
  {
    "id": "knapsack_01",
    "name": "0/1 Knapsack",
    "category": "Dynamic Programming",
    "difficulty": "Intermediate",
    "description": "The 0/1 knapsack dynamic programming algorithm maximizes value subject to a weight constraint by building a DP table of best achievable value.",
    "tags": [
      "dynamic programming",
      "optimization",
      "dp table"
    ],
    "complexity": {
      "best": "O(nW)",
      "average": "O(nW)",
      "worst": "O(nW)",
      "space": "O(nW)"
    },
    "codeSnippets": {
      "python": "\ndef knapsack_01(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            dp[i][w] = dp[i - 1][w]\n            if weights[i - 1] <= w:\n                dp[i][w] = max(dp[i][w], values[i - 1] + dp[i - 1][w - weights[i - 1]])\n    return dp[n][capacity]\n",
      "java": "\npublic int knapsack01(int[] weights, int[] values, int capacity) {\n    int n = weights.length;\n    int[][] dp = new int[n + 1][capacity + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= capacity; w++) {\n            dp[i][w] = dp[i - 1][w];\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(dp[i][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]);\n            }\n        }\n    }\n    return dp[n][capacity];\n}\n",
      "cpp": "\nint knapsack_01(const std::vector<int>& weights, const std::vector<int>& values, int capacity) {\n    int n = static_cast<int>(weights.size());\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(capacity + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        for (int w = 0; w <= capacity; ++w) {\n            dp[i][w] = dp[i - 1][w];\n            if (weights[i - 1] <= w) {\n                dp[i][w] = std::max(dp[i][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]);\n            }\n        }\n    }\n    return dp[n][capacity];\n}\n",
      "csharp": "\npublic int Knapsack01(int[] weights, int[] values, int capacity) {\n    int n = weights.Length;\n    int[,] dp = new int[n + 1, capacity + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= capacity; w++) {\n            dp[i, w] = dp[i - 1, w];\n            if (weights[i - 1] <= w) {\n                dp[i, w] = Math.Max(dp[i, w], values[i - 1] + dp[i - 1, w - weights[i - 1]]);\n            }\n        }\n    }\n    return dp[n, capacity];\n}\n"
    },
    "steps": [
      {
        "title": "Initialize DP table",
        "description": "Create a table where dp[i][w] stores the best value using first i items and capacity w.",
        "frame": {
          "annotations": [
            "dp dimensions = (n+1) x (W+1)"
          ]
        }
      },
      {
        "title": "Transition",
        "description": "For each item decide to skip or take it if weight allows, taking the better value.",
        "frame": {
          "annotations": [
            "dp[i][w] = max(dp[i-1][w], value + dp[i-1][w-weight])"
          ]
        }
      },
      {
        "title": "Read result",
        "description": "The answer is stored at dp[n][capacity] after filling the table.",
        "frame": {
          "annotations": [
            "return dp[n][W]"
          ]
        }
      }
    ]
  },
  {
    "id": "longest_increasing_subsequence",
    "name": "Longest Increasing Subsequence",
    "category": "Dynamic Programming",
    "difficulty": "Intermediate",
    "description": "The patience sorting technique computes the length of the longest increasing subsequence in O(n log n) using binary search on tails.",
    "tags": [
      "dynamic programming",
      "binary search",
      "sequence"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\nimport bisect\n\ndef longest_increasing_subsequence(nums):\n    tails = []\n    for num in nums:\n        index = bisect.bisect_left(tails, num)\n        if index == len(tails):\n            tails.append(num)\n        else:\n            tails[index] = num\n    return len(tails)\n",
      "java": "\npublic int longestIncreasingSubsequence(int[] nums) {\n    List<Integer> tails = new ArrayList<>();\n    for (int num : nums) {\n        int index = Collections.binarySearch(tails, num);\n        if (index < 0) index = -(index + 1);\n        if (index == tails.size()) {\n            tails.add(num);\n        } else {\n            tails.set(index, num);\n        }\n    }\n    return tails.size();\n}\n",
      "cpp": "\nint longest_increasing_subsequence(const std::vector<int>& nums) {\n    std::vector<int> tails;\n    for (int num : nums) {\n        auto it = std::lower_bound(tails.begin(), tails.end(), num);\n        if (it == tails.end()) {\n            tails.push_back(num);\n        } else {\n            *it = num;\n        }\n    }\n    return static_cast<int>(tails.size());\n}\n",
      "csharp": "\npublic int LongestIncreasingSubsequence(int[] nums) {\n    var tails = new List<int>();\n    foreach (var num in nums) {\n        int index = tails.BinarySearch(num);\n        if (index < 0) index = ~index;\n        if (index == tails.Count) {\n            tails.Add(num);\n        } else {\n            tails[index] = num;\n        }\n    }\n    return tails.Count;\n}\n"
    },
    "steps": [
      {
        "title": "Maintain tails",
        "description": "Store the smallest ending value for subsequences of each length in a tails array.",
        "frame": {
          "annotations": [
            "tails[k] = best tail for length k+1"
          ]
        }
      },
      {
        "title": "Binary search per element",
        "description": "Use binary search to place each number, replacing the first tail greater or equal to it.",
        "frame": {
          "annotations": [
            "lower_bound on tails"
          ]
        }
      },
      {
        "title": "Result length",
        "description": "The length of tails equals the LIS length.",
        "frame": {
          "annotations": [
            "len(tails)"
          ]
        }
      }
    ]
  },
  {
    "id": "longest_common_subsequence",
    "name": "Longest Common Subsequence",
    "category": "Dynamic Programming",
    "difficulty": "Intermediate",
    "description": "Dynamic programming fills a matrix where dp[i][j] stores the LCS length between prefixes of two strings.",
    "tags": [
      "dynamic programming",
      "string",
      "dp table"
    ],
    "complexity": {
      "best": "O(nm)",
      "average": "O(nm)",
      "worst": "O(nm)",
      "space": "O(nm)"
    },
    "codeSnippets": {
      "python": "\ndef longest_common_subsequence(a, b):\n    n, m = len(a), len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]\n",
      "java": "\npublic int longestCommonSubsequence(String a, String b) {\n    int n = a.length();\n    int m = b.length();\n    int[][] dp = new int[n + 1][m + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (a.charAt(i - 1) == b.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][m];\n}\n",
      "cpp": "\nint longest_common_subsequence(const std::string& a, const std::string& b) {\n    int n = static_cast<int>(a.size());\n    int m = static_cast<int>(b.size());\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][m];\n}\n",
      "csharp": "\npublic int LongestCommonSubsequence(string a, string b) {\n    int n = a.Length;\n    int m = b.Length;\n    int[,] dp = new int[n + 1, m + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i, j] = dp[i - 1, j - 1] + 1;\n            } else {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n            }\n        }\n    }\n    return dp[n, m];\n}\n"
    },
    "steps": [
      {
        "title": "Initialize matrix",
        "description": "Create a grid for prefix comparisons of strings a and b.",
        "frame": {
          "annotations": [
            "dp size = (n+1)x(m+1)"
          ]
        }
      },
      {
        "title": "Fill transitions",
        "description": "If characters match, take diagonal+1, otherwise take max of removing a char from either string.",
        "frame": {
          "annotations": [
            "match -> diag+1 else max(up,left)"
          ]
        }
      },
      {
        "title": "Extract length",
        "description": "The bottom-right cell contains the LCS length.",
        "frame": {
          "annotations": [
            "answer = dp[n][m]"
          ]
        }
      }
    ]
  },
  {
    "id": "edit_distance",
    "name": "Edit Distance (Levenshtein)",
    "category": "Dynamic Programming",
    "difficulty": "Intermediate",
    "description": "Computes the minimum number of insertions, deletions, and substitutions required to transform one string into another using a DP table.",
    "tags": [
      "dynamic programming",
      "string edit",
      "dp table"
    ],
    "complexity": {
      "best": "O(nm)",
      "average": "O(nm)",
      "worst": "O(nm)",
      "space": "O(nm)"
    },
    "codeSnippets": {
      "python": "\ndef edit_distance(a, b):\n    n, m = len(a), len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = i\n    for j in range(m + 1):\n        dp[0][j] = j\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      # deletion\n                    dp[i][j - 1],      # insertion\n                    dp[i - 1][j - 1],  # substitution\n                )\n    return dp[n][m]\n",
      "java": "\npublic int editDistance(String a, String b) {\n    int n = a.length();\n    int m = b.length();\n    int[][] dp = new int[n + 1][m + 1];\n    for (int i = 0; i <= n; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 0; j <= m; j++) {\n        dp[0][j] = j;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (a.charAt(i - 1) == b.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(\n                        dp[i - 1][j - 1],\n                        Math.min(dp[i - 1][j], dp[i][j - 1])\n                );\n            }\n        }\n    }\n    return dp[n][m];\n}\n",
      "cpp": "\nint edit_distance(const std::string& a, const std::string& b) {\n    int n = static_cast<int>(a.size());\n    int m = static_cast<int>(b.size());\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1));\n    for (int i = 0; i <= n; ++i) dp[i][0] = i;\n    for (int j = 0; j <= m; ++j) dp[0][j] = j;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + std::min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]});\n            }\n        }\n    }\n    return dp[n][m];\n}\n",
      "csharp": "\npublic int EditDistance(string a, string b) {\n    int n = a.Length;\n    int m = b.Length;\n    int[,] dp = new int[n + 1, m + 1];\n    for (int i = 0; i <= n; i++) dp[i, 0] = i;\n    for (int j = 0; j <= m; j++) dp[0, j] = j;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i, j] = dp[i - 1, j - 1];\n            } else {\n                dp[i, j] = 1 + Math.Min(\n                    dp[i - 1, j - 1],\n                    Math.Min(dp[i - 1, j], dp[i, j - 1])\n                );\n            }\n        }\n    }\n    return dp[n, m];\n}\n"
    },
    "steps": [
      {
        "title": "Base cases",
        "description": "Initialize first row/column to represent converting to/from empty string.",
        "frame": {
          "annotations": [
            "dp[i][0] = i",
            "dp[0][j] = j"
          ]
        }
      },
      {
        "title": "Transition",
        "description": "If characters match carry diagonal value; otherwise take min of deletion, insertion, substitution plus one.",
        "frame": {
          "annotations": [
            "match -> diag",
            "else 1 + min"
          ]
        }
      },
      {
        "title": "Answer",
        "description": "The edit distance is stored in dp[n][m].",
        "frame": {
          "annotations": [
            "result dp[n][m]"
          ]
        }
      }
    ]
  },
  {
    "id": "matrix_chain_multiplication",
    "name": "Matrix Chain Multiplication",
    "category": "Dynamic Programming",
    "difficulty": "Advanced",
    "description": "Determines the most efficient parenthesization of matrix multiplication by minimizing scalar multiplications through dynamic programming.",
    "tags": [
      "dynamic programming",
      "matrix",
      "optimization"
    ],
    "complexity": {
      "best": "O(n^3)",
      "average": "O(n^3)",
      "worst": "O(n^3)",
      "space": "O(n^2)"
    },
    "codeSnippets": {
      "python": "\ndef matrix_chain_order(dimensions):\n    n = len(dimensions) - 1\n    dp = [[0] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1]\n                dp[i][j] = min(dp[i][j], cost)\n    return dp[0][n - 1]\n",
      "java": "\npublic int matrixChainOrder(int[] dims) {\n    int n = dims.length - 1;\n    int[][] dp = new int[n][n];\n    for (int length = 2; length <= n; length++) {\n        for (int i = 0; i <= n - length; i++) {\n            int j = i + length - 1;\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = dp[i][k] + dp[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1];\n                dp[i][j] = Math.min(dp[i][j], cost);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n",
      "cpp": "\nint matrix_chain_order(const std::vector<int>& dims) {\n    int n = static_cast<int>(dims.size()) - 1;\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n    for (int length = 2; length <= n; ++length) {\n        for (int i = 0; i <= n - length; ++i) {\n            int j = i + length - 1;\n            dp[i][j] = std::numeric_limits<int>::max();\n            for (int k = i; k < j; ++k) {\n                int cost = dp[i][k] + dp[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1];\n                dp[i][j] = std::min(dp[i][j], cost);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n",
      "csharp": "\npublic int MatrixChainOrder(int[] dims) {\n    int n = dims.Length - 1;\n    int[,] dp = new int[n, n];\n    for (int length = 2; length <= n; length++) {\n        for (int i = 0; i <= n - length; i++) {\n            int j = i + length - 1;\n            dp[i, j] = int.MaxValue;\n            for (int k = i; k < j; k++) {\n                int cost = dp[i, k] + dp[k + 1, j] + dims[i] * dims[k + 1] * dims[j + 1];\n                dp[i, j] = Math.Min(dp[i, j], cost);\n            }\n        }\n    }\n    return dp[0, n - 1];\n}\n"
    },
    "steps": [
      {
        "title": "Define subproblems",
        "description": "dp[i][j] stores best cost to multiply matrices i through j.",
        "frame": {
          "annotations": [
            "state (i,j)"
          ]
        }
      },
      {
        "title": "Check split points",
        "description": "Try every split k between i and j, combining left and right costs plus multiplication cost.",
        "frame": {
          "annotations": [
            "cost = left + right + dims[i]*dims[k+1]*dims[j+1]"
          ]
        }
      },
      {
        "title": "Expand length",
        "description": "Iterate length from 2 to n to fill table diagonally.",
        "frame": {
          "annotations": [
            "length-based iteration"
          ]
        }
      }
    ]
  },
  {
    "id": "coin_change_min",
    "name": "Coin Change (Minimum Coins)",
    "category": "Dynamic Programming",
    "difficulty": "Intermediate",
    "description": "Finds the minimum number of coins needed to reach a target amount using bottom-up dynamic programming.",
    "tags": [
      "dynamic programming",
      "coin change",
      "dp table"
    ],
    "complexity": {
      "best": "O(n * amount)",
      "average": "O(n * amount)",
      "worst": "O(n * amount)",
      "space": "O(amount)"
    },
    "codeSnippets": {
      "python": "\ndef coin_change_min(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for value in range(coin, amount + 1):\n            dp[value] = min(dp[value], dp[value - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n",
      "java": "\npublic int coinChangeMin(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    for (int coin : coins) {\n        for (int value = coin; value <= amount; value++) {\n            dp[value] = Math.min(dp[value], dp[value - coin] + 1);\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n",
      "cpp": "\nint coin_change_min(const std::vector<int>& coins, int amount) {\n    const int INF = amount + 1;\n    std::vector<int> dp(amount + 1, INF);\n    dp[0] = 0;\n    for (int coin : coins) {\n        for (int value = coin; value <= amount; ++value) {\n            dp[value] = std::min(dp[value], dp[value - coin] + 1);\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n",
      "csharp": "\npublic int CoinChangeMin(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Array.Fill(dp, amount + 1);\n    dp[0] = 0;\n    foreach (var coin in coins) {\n        for (int value = coin; value <= amount; value++) {\n            dp[value] = Math.Min(dp[value], dp[value - coin] + 1);\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n"
    },
    "steps": [
      {
        "title": "Initialize dp array",
        "description": "Set dp[0] = 0 and all other values to infinity to represent unreachable states.",
        "frame": {
          "annotations": [
            "dp[0]=0",
            "others = INF"
          ]
        }
      },
      {
        "title": "Iterate coins",
        "description": "For each coin, update reachable amounts by taking minimum of current and using the coin.",
        "frame": {
          "annotations": [
            "dp[v] = min(dp[v], dp[v-coin]+1)"
          ]
        }
      },
      {
        "title": "Check result",
        "description": "If dp[amount] remains INF, no solution exists; otherwise it stores min coins.",
        "frame": {
          "annotations": [
            "return dp[amount]"
          ]
        }
      }
    ]
  },
  {
    "id": "kadane_algorithm",
    "name": "Kadane's Maximum Subarray",
    "category": "Dynamic Programming",
    "difficulty": "Beginner",
    "description": "Kadane's algorithm scans the array while maintaining the best subarray ending at current position to find the maximum subarray sum.",
    "tags": [
      "dynamic programming",
      "array",
      "prefix"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef kadane(nums):\n    current = best = nums[0]\n    for num in nums[1:]:\n        current = max(num, current + num)\n        best = max(best, current)\n    return best\n",
      "java": "\npublic int kadane(int[] nums) {\n    int current = nums[0];\n    int best = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        current = Math.max(nums[i], current + nums[i]);\n        best = Math.max(best, current);\n    }\n    return best;\n}\n",
      "cpp": "\nint kadane(const std::vector<int>& nums) {\n    int current = nums[0];\n    int best = nums[0];\n    for (std::size_t i = 1; i < nums.size(); ++i) {\n        current = std::max(nums[i], current + nums[i]);\n        best = std::max(best, current);\n    }\n    return best;\n}\n",
      "csharp": "\npublic int Kadane(int[] nums) {\n    int current = nums[0];\n    int best = nums[0];\n    for (int i = 1; i < nums.Length; i++) {\n        current = Math.Max(nums[i], current + nums[i]);\n        best = Math.Max(best, current);\n    }\n    return best;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize running sums",
        "description": "Start with current and best set to the first element.",
        "frame": {
          "annotations": [
            "current=best=nums[0]"
          ]
        }
      },
      {
        "title": "Extend or restart",
        "description": "For each element decide to extend previous sequence or start anew.",
        "frame": {
          "annotations": [
            "current = max(num, current+num)"
          ]
        }
      },
      {
        "title": "Track maximum",
        "description": "Best stores the highest subarray sum seen so far.",
        "frame": {
          "annotations": [
            "best = max(best, current)"
          ]
        }
      }
    ]
  },
  {
    "id": "floyd_cycle_detection",
    "name": "Floyd's Cycle Detection",
    "category": "Algorithms",
    "difficulty": "Beginner",
    "description": "Detects cycles in linked lists or iterative sequences using two pointers moving at different speeds (tortoise and hare).",
    "tags": [
      "two pointers",
      "linked list",
      "cycle detection"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow is fast:\n            return True\n    return False\n",
      "java": "\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != None && fast.next != None) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return True;\n        }\n    }\n    return False;\n}\n",
      "cpp": "\nbool has_cycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) return True;\n    }\n    return False;\n}\n",
      "csharp": "\npublic bool HasCycle(ListNode head) {\n    var slow = head;\n    var fast = head;\n    while (fast != None && fast.next != None) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return True;\n        }\n    }\n    return False;\n}\n"
    },
    "steps": [
      {
        "title": "Move pointers",
        "description": "Advance slow by one and fast by two nodes each iteration.",
        "frame": {
          "annotations": [
            "slow = slow.next",
            "fast = fast.next.next"
          ]
        }
      },
      {
        "title": "Cycle detection",
        "description": "If pointers meet, a cycle exists.",
        "frame": {
          "annotations": [
            "if slow == fast -> cycle"
          ]
        }
      },
      {
        "title": "Termination",
        "description": "If fast pointer reaches None, no cycle is present.",
        "frame": {
          "annotations": [
            "fast or fast.next == None -> no cycle"
          ]
        }
      }
    ]
  },
  {
    "id": "sieve_of_eratosthenes",
    "name": "Sieve of Eratosthenes",
    "category": "Mathematics",
    "difficulty": "Beginner",
    "description": "Efficiently identifies all prime numbers up to N by iteratively marking multiples starting from each prime.",
    "tags": [
      "number theory",
      "primes",
      "sieve"
    ],
    "complexity": {
      "best": "O(n log log n)",
      "average": "O(n log log n)",
      "worst": "O(n log log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    p = 2\n    while p * p <= limit:\n        if is_prime[p]:\n            for multiple in range(p * p, limit + 1, p):\n                is_prime[multiple] = False\n        p += 1\n    return [i for i, prime in enumerate(is_prime) if prime]\n",
      "java": "\npublic boolean[] sieveOfEratosthenes(int limit) {\n    boolean[] isPrime = new boolean[limit + 1];\n    Arrays.fill(isPrime, True);\n    if (limit >= 0) isPrime[0] = False;\n    if (limit >= 1) isPrime[1] = False;\n    for (int p = 2; p * p <= limit; p++) {\n        if (isPrime[p]) {\n            for (int multiple = p * p; multiple <= limit; multiple += p) {\n                isPrime[multiple] = False;\n            }\n        }\n    }\n    return isPrime;\n}\n",
      "cpp": "\nstd::vector<bool> sieve_of_eratosthenes(int limit) {\n    std::vector<bool> is_prime(limit + 1, True);\n    if (limit >= 0) is_prime[0] = False;\n    if (limit >= 1) is_prime[1] = False;\n    for (int p = 2; p * p <= limit; ++p) {\n        if (is_prime[p]) {\n            for (int multiple = p * p; multiple <= limit; multiple += p) {\n                is_prime[multiple] = False;\n            }\n        }\n    }\n    return is_prime;\n}\n",
      "csharp": "\npublic bool[] SieveOfEratosthenes(int limit) {\n    var isPrime = Enumerable.Repeat(True, limit + 1).ToArray();\n    if (limit >= 0) isPrime[0] = False;\n    if (limit >= 1) isPrime[1] = False;\n    for (int p = 2; p * p <= limit; p++) {\n        if (isPrime[p]) {\n            for (int multiple = p * p; multiple <= limit; multiple += p) {\n                isPrime[multiple] = False;\n            }\n        }\n    }\n    return isPrime;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize boolean array",
        "description": "Mark all numbers as potentially prime except 0 and 1.",
        "frame": {
          "annotations": [
            "isPrime[0]=isPrime[1]=False"
          ]
        }
      },
      {
        "title": "Mark multiples",
        "description": "For each prime p up to sqrt(limit), mark multiples as composite.",
        "frame": {
          "annotations": [
            "for multiple = p^2 ..."
          ]
        }
      },
      {
        "title": "Collect primes",
        "description": "Remaining True entries correspond to primes.",
        "frame": {
          "annotations": [
            "primes = indices with isPrime=True"
          ]
        }
      }
    ]
  },
  {
    "id": "miller_rabin_primality",
    "name": "Miller\u00e2\u20ac\u201cRabin Primality Test",
    "category": "Mathematics",
    "difficulty": "Advanced",
    "description": "A probabilistic primality test that checks whether a number is composite using repeated modular exponentiation against random bases.",
    "tags": [
      "primality test",
      "modular arithmetic",
      "probabilistic"
    ],
    "complexity": {
      "best": "O(k log^3 n)",
      "average": "O(k log^3 n)",
      "worst": "O(k log^3 n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\nimport random\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        if exponent & 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent >>= 1\n    return result\n\ndef miller_rabin(n, k=5):\n    if n < 2:\n        return False\n    for p in [2, 3, 5, 7, 11]:\n        if n % p == 0:\n            return n == p\n    d = n - 1\n    r = 0\n    while d % 2 == 0:\n        d \n        r += 1\n    for _ in range(k):\n        a = random.randrange(2, n - 2)\n        x = mod_pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = (x * x) % n\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n",
      "java": "\npublic boolean millerRabin(long n, int iterations) {\n    if (n < 2) return False;\n    long[] bases = {2, 3, 5, 7, 11};\n    for (long p : bases) {\n        if (n % p == 0) return n == p;\n    }\n    long d = n - 1;\n    int r = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    ThreadLocalRandom random = ThreadLocalRandom.current();\n    for (int i = 0; i < iterations; i++) {\n        long a = random.nextLong(2, n - 2);\n        long x = modPow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        boolean continueWitness = False;\n        for (int j = 0; j < r - 1; j++) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                continueWitness = True;\n                break;\n            }\n        }\n        if (!continueWitness) return False;\n    }\n    return True;\n}\n\nprivate long modPow(long base, long exponent, long mod) {\n    long result = 1;\n    base %= mod;\n    while (exponent > 0) {\n        if ((exponent & 1) == 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exponent >>= 1;\n    }\n    return result;\n}\n",
      "cpp": "\nlong long mod_pow(long long base, long long exponent, long long mod) {\n    long long result = 1 % mod;\n    base %= mod;\n    while (exponent > 0) {\n        if (exponent & 1) result = (__int128)result * base % mod;\n        base = (__int128)base * base % mod;\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool miller_rabin(long long n, int iterations = 5) {\n    if (n < 2) return False;\n    for (long long p : {2LL, 3LL, 5LL, 7LL, 11LL}) {\n        if (n % p == 0) return n == p;\n    }\n    long long d = n - 1;\n    int r = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++r;\n    }\n    std::mt19937_64 gen(std::random_device{}());\n    std::uniform_int_distribution<long long> dist(2, n - 2);\n    for (int i = 0; i < iterations; ++i) {\n        long long a = dist(gen);\n        long long x = mod_pow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool witness = False;\n        for (int j = 0; j < r - 1; ++j) {\n            x = (__int128)x * x % n;\n            if (x == n - 1) {\n                witness = True;\n                break;\n            }\n        }\n        if (!witness) return False;\n    }\n    return True;\n}\n",
      "csharp": "\npublic bool MillerRabin(long n, int iterations = 5) {\n    if (n < 2) return False;\n    foreach (var p in new long[] { 2, 3, 5, 7, 11 }) {\n        if (n % p == 0) return n == p;\n    }\n    long d = n - 1;\n    int r = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    var random = new Random();\n    for (int i = 0; i < iterations; i++) {\n        long a = random.NextInt64(2, n - 2);\n        long x = ModPow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool witness = False;\n        for (int j = 0; j < r - 1; j++) {\n            x = ModMul(x, x, n);\n            if (x == n - 1) {\n                witness = True;\n                break;\n            }\n        }\n        if (!witness) return False;\n    }\n    return True;\n}\n\nprivate long ModPow(long baseValue, long exponent, long mod) {\n    long result = 1 % mod;\n    baseValue %= mod;\n    while (exponent > 0) {\n        if ((exponent & 1) == 1) result = ModMul(result, baseValue, mod);\n        baseValue = ModMul(baseValue, baseValue, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nprivate long ModMul(long a, long b, long mod) {\n    return (long)((BigInteger)a * b % mod);\n}\n"
    },
    "steps": [
      {
        "title": "Express n-1",
        "description": "Factor n-1 as 2^r * d with d odd.",
        "frame": {
          "annotations": [
            "n-1 = 2^r * d"
          ]
        }
      },
      {
        "title": "Witness loop",
        "description": "Pick bases a and use modular exponentiation to test whether n behaves like a prime.",
        "frame": {
          "annotations": [
            "check a^d mod n and repeated squaring"
          ]
        }
      },
      {
        "title": "Probabilistic result",
        "description": "If all tested bases pass, n is probably prime; otherwise composite.",
        "frame": {
          "annotations": [
            "composite if witness found"
          ]
        }
      }
    ]
  },
  {
    "id": "binary_exponentiation",
    "name": "Binary Exponentiation",
    "category": "Mathematics",
    "difficulty": "Beginner",
    "description": "Fast exponentiation algorithm using repeated squaring to compute power in logarithmic time.",
    "tags": [
      "exponentiation",
      "divide and conquer",
      "modular arithmetic"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef binary_pow(base, exponent, modulus=None):\n    result = 1\n    while exponent > 0:\n        if exponent & 1:\n            result = result * base if modulus is None else (result * base) % modulus\n        base = base * base if modulus is None else (base * base) % modulus\n        exponent >>= 1\n    return result\n",
      "java": "\npublic long binaryPow(long base, long exponent, long modulus) {\n    long result = 1 % modulus;\n    base %= modulus;\n    while (exponent > 0) {\n        if ((exponent & 1) == 1) {\n            result = (result * base) % modulus;\n        }\n        base = (base * base) % modulus;\n        exponent >>= 1;\n    }\n    return result;\n}\n",
      "cpp": "\nlong long binary_pow(long long base, long long exponent, long long modulus) {\n    long long result = 1 % modulus;\n    base %= modulus;\n    while (exponent > 0) {\n        if (exponent & 1) result = (__int128)result * base % modulus;\n        base = (__int128)base * base % modulus;\n        exponent >>= 1;\n    }\n    return result;\n}\n",
      "csharp": "\npublic long BinaryPow(long baseValue, long exponent, long modulus) {\n    long result = 1 % modulus;\n    baseValue %= modulus;\n    while (exponent > 0) {\n        if ((exponent & 1) == 1) result = (result * baseValue) % modulus;\n        baseValue = (baseValue * baseValue) % modulus;\n        exponent >>= 1;\n    }\n    return result;\n}\n"
    },
    "steps": [
      {
        "title": "Inspect bit",
        "description": "Multiply result by base when current bit of exponent is set.",
        "frame": {
          "annotations": [
            "if exponent & 1 -> result *= base"
          ]
        }
      },
      {
        "title": "Square base",
        "description": "Square base each iteration to represent powers of two.",
        "frame": {
          "annotations": [
            "base = base^2"
          ]
        }
      },
      {
        "title": "Shift exponent",
        "description": "Right shift exponent to process next bit.",
        "frame": {
          "annotations": [
            "exponent >>= 1"
          ]
        }
      }
    ]
  },
  {
    "id": "fast_fourier_transform",
    "name": "Fast Fourier Transform (Cooley\u00e2\u20ac\u201cTukey)",
    "category": "Mathematics",
    "difficulty": "Advanced",
    "description": "FFT recursively combines even and odd coefficient evaluations to transform polynomials between time and frequency domains in O(n log n).",
    "tags": [
      "fft",
      "divide and conquer",
      "polynomial"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\nimport cmath\n\ndef fft(a, invert=False):\n    n = len(a)\n    if n == 1:\n        return a\n    a_even = fft(a[0::2], invert)\n    a_odd = fft(a[1::2], invert)\n    angle = 2 * cmath.pi / n * (-1 if invert else 1)\n    w = 1\n    wn = cmath.exp(1j * angle)\n    y = [0] * n\n    for k in range(n \n        u = a_even[k]\n        v = w * a_odd[k]\n        y[k] = u + v\n        y[k + n \n        w *= wn\n    if invert:\n        y = [value / 2 for value in y]\n    return y\n",
      "java": "\npublic void fft(Complex[] a, boolean invert) {\n    int n = a.length;\n    if (n == 1) return;\n    Complex[] even = new Complex[n / 2];\n    Complex[] odd = new Complex[n / 2];\n    for (int i = 0; 2 * i < n; i++) {\n        even[i] = a[2 * i];\n        odd[i] = a[2 * i + 1];\n    }\n    fft(even, invert);\n    fft(odd, invert);\n    double angle = 2 * Math.PI / n * (invert ? -1 : 1);\n    Complex wn = Complex.fromPolar(1, angle);\n    Complex w = Complex.ONE;\n    for (int k = 0; 2 * k < n; k++) {\n        Complex u = even[k];\n        Complex v = w.multiply(odd[k]);\n        a[k] = u.add(v);\n        a[k + n / 2] = u.subtract(v);\n        if (invert) {\n            a[k] = a[k].divide(2);\n            a[k + n / 2] = a[k + n / 2].divide(2);\n        }\n        w = w.multiply(wn);\n    }\n}\n",
      "cpp": "\nusing Complex = std::complex<double>;\n\nvoid fft(std::vector<Complex>& a, bool invert) {\n    int n = static_cast<int>(a.size());\n    if (n == 1) return;\n    std::vector<Complex> a_even(n / 2), a_odd(n / 2);\n    for (int i = 0; 2 * i < n; ++i) {\n        a_even[i] = a[2 * i];\n        a_odd[i] = a[2 * i + 1];\n    }\n    fft(a_even, invert);\n    fft(a_odd, invert);\n    double angle = 2 * M_PI / n * (invert ? -1 : 1);\n    Complex w(1);\n    Complex wn(std::cos(angle), std::sin(angle));\n    for (int k = 0; 2 * k < n; ++k) {\n        Complex u = a_even[k];\n        Complex v = w * a_odd[k];\n        a[k] = u + v;\n        a[k + n / 2] = u - v;\n        if (invert) {\n            a[k] /= 2;\n            a[k + n / 2] /= 2;\n        }\n        w *= wn;\n    }\n}\n",
      "csharp": "\npublic void Fft(Complex[] a, bool invert) {\n    int n = a.Length;\n    if (n == 1) return;\n    var even = new Complex[n / 2];\n    var odd = new Complex[n / 2];\n    for (int i = 0; 2 * i < n; i++) {\n        even[i] = a[2 * i];\n        odd[i] = a[2 * i + 1];\n    }\n    Fft(even, invert);\n    Fft(odd, invert);\n    double angle = 2 * Math.PI / n * (invert ? -1 : 1);\n    Complex wn = Complex.FromPolarCoordinates(1, angle);\n    Complex w = Complex.One;\n    for (int k = 0; 2 * k < n; k++) {\n        Complex u = even[k];\n        Complex v = w * odd[k];\n        a[k] = u + v;\n        a[k + n / 2] = u - v;\n        if (invert) {\n            a[k] /= 2;\n            a[k + n / 2] /= 2;\n        }\n        w *= wn;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Divide sequence",
        "description": "Split coefficients into even and odd indices recursively.",
        "frame": {
          "annotations": [
            "recurse on even/odd"
          ]
        }
      },
      {
        "title": "Combine results",
        "description": "Use n-th roots of unity to merge partial transforms.",
        "frame": {
          "annotations": [
            "butterfly operations"
          ]
        }
      },
      {
        "title": "Inverse transform",
        "description": "If performing inverse FFT, divide outputs by two at each level.",
        "frame": {
          "annotations": [
            "normalize on invert"
          ]
        }
      }
    ]
  },
  {
    "id": "convex_hull_graham",
    "name": "Convex Hull (Graham Scan)",
    "category": "Geometry",
    "difficulty": "Intermediate",
    "description": "Computes the convex hull of planar points by sorting by polar angle and maintaining a stack that enforces counter-clockwise turns.",
    "tags": [
      "computational geometry",
      "convex hull",
      "stack"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef graham_scan(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n",
      "java": "\npublic List<Point> grahamScan(List<Point> points) {\n    points.sort(Comparator.comparingInt((Point p) -> p.x).thenComparingInt(p -> p.y));\n    if (points.size() <= 1) {\n        return points;\n    }\n    List<Point> lower = new ArrayList<>();\n    for (Point p : points) {\n        while (lower.size() >= 2 && cross(lower.get(lower.size() - 2), lower.get(lower.size() - 1), p) <= 0) {\n            lower.remove(lower.size() - 1);\n        }\n        lower.add(p);\n    }\n    List<Point> upper = new ArrayList<>();\n    for (int i = points.size() - 1; i >= 0; i--) {\n        Point p = points.get(i);\n        while (upper.size() >= 2 && cross(upper.get(upper.size() - 2), upper.get(upper.size() - 1), p) <= 0) {\n            upper.remove(upper.size() - 1);\n        }\n        upper.add(p);\n    }\n    lower.remove(lower.size() - 1);\n    upper.remove(upper.size() - 1);\n    lower.addAll(upper);\n    return lower;\n}\n\nprivate int cross(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n",
      "cpp": "\nstruct Point { double x, y; };\n\ndouble cross(const Point& o, const Point& a, const Point& b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\nstd::vector<Point> graham_scan(std::vector<Point> points) {\n    std::sort(points.begin(), points.end(), [](const Point& lhs, const Point& rhs) {\n        if (lhs.x == rhs.x) return lhs.y < rhs.y;\n        return lhs.x < rhs.x;\n    });\n    if (points.size() <= 1) return points;\n    std::vector<Point> lower, upper;\n    for (const auto& p : points) {\n        while (lower.size() >= 2 && cross(lower[lower.size()-2], lower.back(), p) <= 0) {\n            lower.pop_back();\n        }\n        lower.push_back(p);\n    }\n    for (auto it = points.rbegin(); it != points.rend(); ++it) {\n        while (upper.size() >= 2 && cross(upper[upper.size()-2], upper.back(), *it) <= 0) {\n            upper.pop_back();\n        }\n        upper.push_back(*it);\n    }\n    lower.pop_back();\n    upper.pop_back();\n    lower.insert(lower.end(), upper.begin(), upper.end());\n    return lower;\n}\n",
      "csharp": "\npublic IList<Point> GrahamScan(IList<Point> points) {\n    var sorted = points.OrderBy(p => p.X).ThenBy(p => p.Y).ToList();\n    if (sorted.Count <= 1) return sorted;\n    var lower = new List<Point>();\n    foreach (var p in sorted) {\n        while (lower.Count >= 2 && Cross(lower[^2], lower[^1], p) <= 0) {\n            lower.RemoveAt(lower.Count - 1);\n        }\n        lower.Add(p);\n    }\n    var upper = new List<Point>();\n    for (int i = sorted.Count - 1; i >= 0; i--) {\n        var p = sorted[i];\n        while (upper.Count >= 2 && Cross(upper[^2], upper[^1], p) <= 0) {\n            upper.RemoveAt(upper.Count - 1);\n        }\n        upper.Add(p);\n    }\n    lower.RemoveAt(lower.Count - 1);\n    upper.RemoveAt(upper.Count - 1);\n    lower.AddRange(upper);\n    return lower;\n}\n\nprivate static double Cross(Point o, Point a, Point b) =>\n    (a.X - o.X) * (b.Y - o.Y) - (a.Y - o.Y) * (b.X - o.X);\n"
    },
    "steps": [
      {
        "title": "Sort points",
        "description": "Sort by x then y to locate pivot and guarantee processing order.",
        "frame": {
          "annotations": [
            "sort points lexicographically"
          ]
        }
      },
      {
        "title": "Build lower hull",
        "description": "Iteratively add points forcing counter-clockwise turns by popping last point if necessary.",
        "frame": {
          "annotations": [
            "while cross <=0 pop"
          ]
        }
      },
      {
        "title": "Build upper hull",
        "description": "Repeat on reversed order and concatenate to produce convex hull.",
        "frame": {
          "annotations": [
            "concatenate lower and upper"
          ]
        }
      }
    ]
  },
  {
    "id": "line_sweep_interval_scheduling",
    "name": "Line Sweep Interval Scheduling",
    "category": "Geometry",
    "difficulty": "Intermediate",
    "description": "Uses a sweep line on interval endpoints to detect overlaps or count active intervals efficiently.",
    "tags": [
      "line sweep",
      "events",
      "intervals"
    ],
    "complexity": {
      "best": "O(n log n)",
      "average": "O(n log n)",
      "worst": "O(n log n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef max_overlapping_intervals(intervals):\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))\n        events.append((end, -1))\n    events.sort()\n    active = 0\n    best = 0\n    for _, delta in events:\n        active += delta\n        best = max(best, active)\n    return best\n",
      "java": "\npublic int maxOverlappingIntervals(int[][] intervals) {\n    List<int[]> events = new ArrayList<>();\n    for (int[] interval : intervals) {\n        events.add(new int[]{interval[0], 1});\n        events.add(new int[]{interval[1], -1});\n    }\n    events.sort(Comparator.<int[]>comparingInt(e -> e[0]).thenComparingInt(e -> e[1]));\n    int active = 0;\n    int best = 0;\n    for (int[] event : events) {\n        active += event[1];\n        best = Math.max(best, active);\n    }\n    return best;\n}\n",
      "cpp": "\nint max_overlapping_intervals(const std::vector<std::pair<int, int>>& intervals) {\n    std::vector<std::pair<int, int>> events;\n    for (const auto& [start, end] : intervals) {\n        events.emplace_back(start, 1);\n        events.emplace_back(end, -1);\n    }\n    std::sort(events.begin(), events.end(),\n              [](const auto& lhs, const auto& rhs) {\n                  if (lhs.first == rhs.first) return lhs.second < rhs.second;\n                  return lhs.first < rhs.first;\n              });\n    int active = 0;\n    int best = 0;\n    for (const auto& [_, delta] : events) {\n        active += delta;\n        best = std::max(best, active);\n    }\n    return best;\n}\n",
      "csharp": "\npublic int MaxOverlappingIntervals(IList<(int start, int end)> intervals) {\n    var events = new List<(int time, int delta)>();\n    foreach (var (start, end) in intervals) {\n        events.Add((start, 1));\n        events.Add((end, -1));\n    }\n    events.Sort((a, b) => a.time == b.time ? a.delta.CompareTo(b.delta) : a.time.CompareTo(b.time));\n    int active = 0;\n    int best = 0;\n    foreach (var (_, delta) in events) {\n        active += delta;\n        best = Math.Max(best, active);\n    }\n    return best;\n}\n"
    },
    "steps": [
      {
        "title": "Create events",
        "description": "Represent each interval start as +1 and end as -1.",
        "frame": {
          "annotations": [
            "events: (time, delta)"
          ]
        }
      },
      {
        "title": "Sort by time",
        "description": "Sort events chronologically, processing end events before start if equal.",
        "frame": {
          "annotations": [
            "sort events"
          ]
        }
      },
      {
        "title": "Sweep accumulation",
        "description": "Traverse events, updating count of active intervals and track maximum.",
        "frame": {
          "annotations": [
            "active += delta",
            "best = max(best, active)"
          ]
        }
      }
    ]
  },
  {
    "id": "two_sat",
    "name": "2-SAT (Implication Graph)",
    "category": "Graph Theory",
    "difficulty": "Advanced",
    "description": "Solves boolean formulas with two literals per clause by building an implication graph and finding strongly connected components.",
    "tags": [
      "2-sat",
      "implication graph",
      "scc"
    ],
    "complexity": {
      "best": "O(n + m)",
      "average": "O(n + m)",
      "worst": "O(n + m)",
      "space": "O(n + m)"
    },
    "codeSnippets": {
      "python": "\ndef two_sat(num_variables, clauses):\n    graph = [[] for _ in range(2 * num_variables)]\n    graph_rev = [[] for _ in range(2 * num_variables)]\n\n    def var_index(x):\n        v = abs(x) - 1\n        return 2 * v + (0 if x > 0 else 1)\n\n    def add_implication(u, v):\n        graph[u].append(v)\n        graph_rev[v].append(u)\n\n    for a, b in clauses:\n        add_implication(var_index(-a), var_index(b))\n        add_implication(var_index(-b), var_index(a))\n\n    order = []\n    visited = [False] * (2 * num_variables)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        order.append(node)\n\n    for node in range(2 * num_variables):\n        if not visited[node]:\n            dfs(node)\n\n    comp = [-1] * (2 * num_variables)\n\n    def dfs_rev(node, label):\n        comp[node] = label\n        for neighbor in graph_rev[node]:\n            if comp[neighbor] == -1:\n                dfs_rev(neighbor, label)\n\n    label = 0\n    for node in reversed(order):\n        if comp[node] == -1:\n            dfs_rev(node, label)\n            label += 1\n\n    assignment = [False] * num_variables\n    for i in range(num_variables):\n        if comp[2 * i] == comp[2 * i + 1]:\n            return None  # unsatisfiable\n        assignment[i] = comp[2 * i] > comp[2 * i + 1]\n    return assignment\n",
      "java": "\npublic boolean[] twoSat(int numVariables, int[][] clauses) {\n    int n = numVariables * 2;\n    List<Integer>[] graph = new List[n];\n    List<Integer>[] graphRev = new List[n];\n    for (int i = 0; i < n; i++) {\n        graph[i] = new ArrayList<>();\n        graphRev[i] = new ArrayList<>();\n    }\n\n    BiConsumer<Integer, Integer> addImplication = (u, v) -> {\n        graph[u].add(v);\n        graphRev[v].add(u);\n    };\n\n    for (int[] clause : clauses) {\n        int a = clause[0];\n        int b = clause[1];\n        addImplication.accept(varIndex(-a), varIndex(b));\n        addImplication.accept(varIndex(-b), varIndex(a));\n    }\n\n    List<Integer> order = new ArrayList<>();\n    boolean[] visited = new boolean[n];\n    for (int node = 0; node < n; node++) {\n        if (!visited[node]) {\n            dfs(graph, node, visited, order);\n        }\n    }\n\n    int[] comp = new int[n];\n    Arrays.fill(comp, -1);\n    int label = 0;\n    for (int i = order.size() - 1; i >= 0; i--) {\n        int node = order.get(i);\n        if (comp[node] == -1) {\n            dfsRev(graphRev, node, label++, comp);\n        }\n    }\n\n    boolean[] assignment = new boolean[numVariables];\n    for (int i = 0; i < numVariables; i++) {\n        if (comp[2 * i] == comp[2 * i + 1]) {\n            return None;\n        }\n        assignment[i] = comp[2 * i] > comp[2 * i + 1];\n    }\n    return assignment;\n}\n\nprivate int varIndex(int literal) {\n    int v = Math.abs(literal) - 1;\n    return 2 * v + (literal > 0 ? 0 : 1);\n}\n\nprivate void dfs(List<Integer>[] graph, int node, boolean[] visited, List<Integer> order) {\n    visited[node] = True;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(graph, neighbor, visited, order);\n        }\n    }\n    order.add(node);\n}\n\nprivate void dfsRev(List<Integer>[] graphRev, int node, int label, int[] comp) {\n    comp[node] = label;\n    for (int neighbor : graphRev[node]) {\n        if (comp[neighbor] == -1) {\n            dfsRev(graphRev, neighbor, label, comp);\n        }\n    }\n}\n",
      "cpp": "\nint var_index(int literal) {\n    int v = std::abs(literal) - 1;\n    return 2 * v + (literal > 0 ? 0 : 1);\n}\n\nstd::vector<int> two_sat(int num_variables, const std::vector<std::pair<int, int>>& clauses) {\n    int n = num_variables * 2;\n    std::vector<std::vector<int>> graph(n), graph_rev(n);\n    auto add_implication = [&](int u, int v) {\n        graph[u].push_back(v);\n        graph_rev[v].push_back(u);\n    };\n    for (auto [a, b] : clauses) {\n        add_implication(var_index(-a), var_index(b));\n        add_implication(var_index(-b), var_index(a));\n    }\n    std::vector<int> order;\n    std::vector<bool> visited(n, False);\n    std::function<void(int)> dfs = [&](int node) {\n        visited[node] = True;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) dfs(neighbor);\n        }\n        order.push_back(node);\n    };\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) dfs(i);\n    }\n    std::vector<int> comp(n, -1);\n    std::function<void(int, int)> dfs_rev = [&](int node, int label) {\n        comp[node] = label;\n        for (int neighbor : graph_rev[node]) {\n            if (comp[neighbor] == -1) dfs_rev(neighbor, label);\n        }\n    };\n    int label = 0;\n    for (int i = static_cast<int>(order.size()) - 1; i >= 0; --i) {\n        int node = order[i];\n        if (comp[node] == -1) {\n            dfs_rev(node, label++);\n        }\n    }\n    std::vector<int> assignment(num_variables);\n    for (int i = 0; i < num_variables; ++i) {\n        if (comp[2 * i] == comp[2 * i + 1]) return {};\n        assignment[i] = comp[2 * i] > comp[2 * i + 1];\n    }\n    return assignment;\n}\n",
      "csharp": "\npublic bool[] TwoSat(int numVariables, IList<(int a, int b)> clauses) {\n    int n = numVariables * 2;\n    var graph = Enumerable.Range(0, n).Select(_ => new List<int>()).ToArray();\n    var graphRev = Enumerable.Range(0, n).Select(_ => new List<int>()).ToArray();\n    void AddImplication(int u, int v) {\n        graph[u].Add(v);\n        graphRev[v].Add(u);\n    }\n    foreach (var (a, b) in clauses) {\n        AddImplication(VarIndex(-a), VarIndex(b));\n        AddImplication(VarIndex(-b), VarIndex(a));\n    }\n    var order = new List<int>();\n    var visited = new bool[n];\n    void Dfs(int node) {\n        visited[node] = True;\n        foreach (var neighbor in graph[node]) {\n            if (!visited[neighbor]) Dfs(neighbor);\n        }\n        order.Add(node);\n    }\n    for (int node = 0; node < n; node++) {\n        if (!visited[node]) Dfs(node);\n    }\n    var comp = Enumerable.Repeat(-1, n).ToArray();\n    void DfsRev(int node, int label) {\n        comp[node] = label;\n        foreach (var neighbor in graphRev[node]) {\n            if (comp[neighbor] == -1) DfsRev(neighbor, label);\n        }\n    }\n    int labelCounter = 0;\n    for (int i = order.Count - 1; i >= 0; i--) {\n        int node = order[i];\n        if (comp[node] == -1) DfsRev(node, labelCounter++);\n    }\n    var assignment = new bool[numVariables];\n    for (int i = 0; i < numVariables; i++) {\n        if (comp[2 * i] == comp[2 * i + 1]) return None;\n        assignment[i] = comp[2 * i] > comp[2 * i + 1];\n    }\n    return assignment;\n}\n\nprivate int VarIndex(int literal) {\n    int v = Math.Abs(literal) - 1;\n    return 2 * v + (literal > 0 ? 0 : 1);\n}\n"
    },
    "steps": [
      {
        "title": "Build implication graph",
        "description": "Each clause (a \u00e2\u02c6\u00a8 b) adds implications (\u00c2\u00aca \u00e2\u2020\u2019 b) and (\u00c2\u00acb \u00e2\u2020\u2019 a).",
        "frame": {
          "annotations": [
            "implication graph edges"
          ]
        }
      },
      {
        "title": "Compute SCCs",
        "description": "Run Kosaraju or Tarjan to find strongly connected components.",
        "frame": {
          "annotations": [
            "SCC decomposition"
          ]
        }
      },
      {
        "title": "Derive assignment",
        "description": "If a variable and its negation share an SCC, unsatisfiable; otherwise assign by topological order.",
        "frame": {
          "annotations": [
            "assignment from SCC order"
          ]
        }
      }
    ]
  },
  {
    "id": "rabin_karp",
    "name": "Rabin\u00e2\u20ac\u201cKarp String Search",
    "category": "Strings",
    "difficulty": "Intermediate",
    "description": "Uses rolling hash to find pattern occurrences in text efficiently, comparing hashes and verifying matches.",
    "tags": [
      "string search",
      "rolling hash",
      "pattern matching"
    ],
    "complexity": {
      "best": "O(n + m)",
      "average": "O(n + m)",
      "worst": "O(nm)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef rabin_karp(text, pattern, base=256, modulus=101):\n    n, m = len(text), len(pattern)\n    if m == 0 or m > n:\n        return []\n    h = pow(base, m - 1, modulus)\n    pattern_hash = 0\n    window_hash = 0\n    for i in range(m):\n        pattern_hash = (pattern_hash * base + ord(pattern[i])) % modulus\n        window_hash = (window_hash * base + ord(text[i])) % modulus\n    matches = []\n    for i in range(n - m + 1):\n        if pattern_hash == window_hash and text[i:i + m] == pattern:\n            matches.append(i)\n        if i < n - m:\n            window_hash = (window_hash - ord(text[i]) * h) % modulus\n            window_hash = (window_hash * base + ord(text[i + m])) % modulus\n            window_hash = (window_hash + modulus) % modulus\n    return matches\n",
      "java": "\npublic List<Integer> rabinKarp(String text, String pattern, int base, int modulus) {\n    int n = text.length();\n    int m = pattern.length();\n    if (m == 0 || m > n) return List.of();\n    int h = 1;\n    for (int i = 0; i < m - 1; i++) {\n        h = (h * base) % modulus;\n    }\n    int patternHash = 0;\n    int windowHash = 0;\n    for (int i = 0; i < m; i++) {\n        patternHash = (patternHash * base + pattern.charAt(i)) % modulus;\n        windowHash = (windowHash * base + text.charAt(i)) % modulus;\n    }\n    List<Integer> matches = new ArrayList<>();\n    for (int i = 0; i <= n - m; i++) {\n        if (patternHash == windowHash && text.regionMatches(i, pattern, 0, m)) {\n            matches.add(i);\n        }\n        if (i < n - m) {\n            windowHash = (windowHash - text.charAt(i) * h) % modulus;\n            windowHash = (windowHash * base + text.charAt(i + m)) % modulus;\n            if (windowHash < 0) windowHash += modulus;\n        }\n    }\n    return matches;\n}\n",
      "cpp": "\nstd::vector<int> rabin_karp(const std::string& text, const std::string& pattern, int base = 256, int modulus = 101) {\n    int n = static_cast<int>(text.size());\n    int m = static_cast<int>(pattern.size());\n    if (m == 0 || m > n) return {};\n    int h = 1;\n    for (int i = 0; i < m - 1; ++i) {\n        h = (h * base) % modulus;\n    }\n    int pattern_hash = 0;\n    int window_hash = 0;\n    for (int i = 0; i < m; ++i) {\n        pattern_hash = (pattern_hash * base + pattern[i]) % modulus;\n        window_hash = (window_hash * base + text[i]) % modulus;\n    }\n    std::vector<int> matches;\n    for (int i = 0; i <= n - m; ++i) {\n        if (pattern_hash == window_hash && text.substr(i, m) == pattern) {\n            matches.push_back(i);\n        }\n        if (i < n - m) {\n            window_hash = (window_hash - text[i] * h) % modulus;\n            window_hash = (window_hash * base + text[i + m]) % modulus;\n            if (window_hash < 0) window_hash += modulus;\n        }\n    }\n    return matches;\n}\n",
      "csharp": "\npublic IList<int> RabinKarp(string text, string pattern, int @base = 256, int modulus = 101) {\n    int n = text.Length;\n    int m = pattern.Length;\n    if (m == 0 || m > n) return Array.Empty<int>();\n    int h = 1;\n    for (int i = 0; i < m - 1; i++) {\n        h = (h * @base) % modulus;\n    }\n    int patternHash = 0;\n    int windowHash = 0;\n    for (int i = 0; i < m; i++) {\n        patternHash = (patternHash * @base + pattern[i]) % modulus;\n        windowHash = (windowHash * @base + text[i]) % modulus;\n    }\n    var matches = new List<int>();\n    for (int i = 0; i <= n - m; i++) {\n        if (patternHash == windowHash && text.AsSpan(i, m).SequenceEqual(pattern)) {\n            matches.Add(i);\n        }\n        if (i < n - m) {\n            windowHash = (windowHash - text[i] * h) % modulus;\n            windowHash = (windowHash * @base + text[i + m]) % modulus;\n            if (windowHash < 0) windowHash += modulus;\n        }\n    }\n    return matches;\n}\n"
    },
    "steps": [
      {
        "title": "Compute rolling hashes",
        "description": "Maintain hash of pattern and current window in text.",
        "frame": {
          "annotations": [
            "pattern_hash",
            "window_hash"
          ]
        }
      },
      {
        "title": "Slide window",
        "description": "Update hash in O(1) when moving one position in text.",
        "frame": {
          "annotations": [
            "subtract outgoing char, add incoming"
          ]
        }
      },
      {
        "title": "Verify matches",
        "description": "When hashes match, compare substrings to avoid collision False positives.",
        "frame": {
          "annotations": [
            "verify text[i:i+m]"
          ]
        }
      }
    ]
  },
  {
    "id": "kmp_string_matching",
    "name": "Knuth\u00e2\u20ac\u201cMorris\u00e2\u20ac\u201cPratt",
    "category": "Strings",
    "difficulty": "Intermediate",
    "description": "KMP preprocesses the pattern to compute longest prefix suffix array (LPS) and uses it to avoid redundant comparisons during search.",
    "tags": [
      "string search",
      "prefix function",
      "pattern matching"
    ],
    "complexity": {
      "best": "O(n + m)",
      "average": "O(n + m)",
      "worst": "O(n + m)",
      "space": "O(m)"
    },
    "codeSnippets": {
      "python": "\ndef kmp_search(text, pattern):\n    n, m = len(text), len(pattern)\n    if m == 0:\n        return []\n    lps = [0] * m\n    length = 0\n    i = 1\n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    matches = []\n    i = j = 0\n    while i < n:\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n        if j == m:\n            matches.append(i - j)\n            j = lps[j - 1]\n        elif i < n and text[i] != pattern[j]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return matches\n",
      "java": "\npublic List<Integer> kmpSearch(String text, String pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    if (m == 0) return List.of();\n    int[] lps = computeLps(pattern);\n    List<Integer> matches = new ArrayList<>();\n    int i = 0, j = 0;\n    while (i < n) {\n        if (text.charAt(i) == pattern.charAt(j)) {\n            i++;\n            j++;\n        }\n        if (j == m) {\n            matches.add(i - j);\n            j = lps[j - 1];\n        } else if (i < n && text.charAt(i) != pattern.charAt(j)) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return matches;\n}\n\nprivate int[] computeLps(String pattern) {\n    int m = pattern.length();\n    int[] lps = new int[m];\n    int len = 0;\n    for (int i = 1; i < m; ) {\n        if (pattern.charAt(i) == pattern.charAt(len)) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n    return lps;\n}\n",
      "cpp": "\nstd::vector<int> kmp_search(const std::string& text, const std::string& pattern) {\n    int n = static_cast<int>(text.size());\n    int m = static_cast<int>(pattern.size());\n    if (m == 0) return {};\n    std::vector<int> lps(m, 0);\n    for (int len = 0, i = 1; i < m;) {\n        if (pattern[i] == pattern[len]) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n    std::vector<int> matches;\n    for (int i = 0, j = 0; i < n;) {\n        if (text[i] == pattern[j]) {\n            i++; j++;\n        }\n        if (j == m) {\n            matches.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < n && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return matches;\n}\n",
      "csharp": "\npublic IList<int> KmpSearch(string text, string pattern) {\n    int n = text.Length;\n    int m = pattern.Length;\n    if (m == 0) return Array.Empty<int>();\n    var lps = ComputeLps(pattern);\n    var matches = new List<int>();\n    int i = 0, j = 0;\n    while (i < n) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == m) {\n            matches.Add(i - j);\n            j = lps[j - 1];\n        } else if (i < n && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return matches;\n}\n\nprivate static int[] ComputeLps(string pattern) {\n    int m = pattern.Length;\n    var lps = new int[m];\n    int len = 0;\n    for (int i = 1; i < m; ) {\n        if (pattern[i] == pattern[len]) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n    return lps;\n}\n"
    },
    "steps": [
      {
        "title": "Precompute LPS",
        "description": "LPS array stores longest proper prefix that is also suffix for pattern prefixes.",
        "frame": {
          "annotations": [
            "compute LPS"
          ]
        }
      },
      {
        "title": "Scan text",
        "description": "Advance in text while referencing LPS to align pattern quickly after mismatch.",
        "frame": {
          "annotations": [
            "j = lps[j-1]"
          ]
        }
      },
      {
        "title": "Record matches",
        "description": "Whenever j reaches pattern length, record occurrence and continue using LPS.",
        "frame": {
          "annotations": [
            "match at i-j"
          ]
        }
      }
    ]
  },
  {
    "id": "z_algorithm",
    "name": "Z-Algorithm",
    "category": "Strings",
    "difficulty": "Intermediate",
    "description": "Computes Z-array where Z[i] is the length of the longest substring starting at i that matches the prefix, useful for pattern matching.",
    "tags": [
      "string processing",
      "z-array",
      "pattern matching"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef z_algorithm(s):\n    n = len(s)\n    z = [0] * n\n    l = r = 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    z[0] = n\n    return z\n",
      "java": "\npublic int[] zAlgorithm(String s) {\n    int n = s.length();\n    int[] z = new int[n];\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            z[i] = Math.min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) {\n            z[i]++;\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    z[0] = n;\n    return z;\n}\n",
      "cpp": "\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = static_cast<int>(s.size());\n    std::vector<int> z(n, 0);\n    int l = 0, r = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i <= r) {\n            z[i] = std::min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            ++z[i];\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    z[0] = n;\n    return z;\n}\n",
      "csharp": "\npublic int[] ZAlgorithm(string s) {\n    int n = s.Length;\n    var z = new int[n];\n    int l = 0, r = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r) {\n            z[i] = Math.Min(r - i + 1, z[i - l]);\n        }\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if (i + z[i] - 1 > r) {\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    z[0] = n;\n    return z;\n}\n"
    },
    "steps": [
      {
        "title": "Maintain Z-box",
        "description": "Track current [l, r] segment matching prefix to reuse comparisons.",
        "frame": {
          "annotations": [
            "l, r pointers"
          ]
        }
      },
      {
        "title": "Reuse previous values",
        "description": "When inside box, initialize z[i] using previously computed values.",
        "frame": {
          "annotations": [
            "z[i] = min(...)"
          ]
        }
      },
      {
        "title": "Expand match",
        "description": "Extend beyond box with direct comparisons and update box if necessary.",
        "frame": {
          "annotations": [
            "while match -> increment"
          ]
        }
      }
    ]
  },
  {
    "id": "manacher_algorithm",
    "name": "Manacher's Palindromic Substrings",
    "category": "Strings",
    "difficulty": "Advanced",
    "description": "Manacher's algorithm finds longest palindromic substring in linear time by expanding around centers while reusing previous information.",
    "tags": [
      "palindrome",
      "string",
      "center expansion"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n)",
      "space": "O(n)"
    },
    "codeSnippets": {
      "python": "\ndef manacher(s):\n    transformed = '^#' + '#'.join(s) + '#$'\n    n = len(transformed)\n    radius = [0] * n\n    center = right = 0\n    for i in range(1, n - 1):\n        mirror = 2 * center - i\n        if i < right:\n            radius[i] = min(right - i, radius[mirror])\n        while transformed[i + radius[i] + 1] == transformed[i - radius[i] - 1]:\n            radius[i] += 1\n        if i + radius[i] > right:\n            center = i\n            right = i + radius[i]\n    max_len = max(radius)\n    center_index = radius.index(max_len)\n    start = (center_index - max_len) \n    return s[start:start + max_len]\n",
      "java": "\npublic String manacher(String s) {\n    char[] transformed = transform(s);\n    int n = transformed.length;\n    int[] radius = new int[n];\n    int center = 0, right = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int mirror = 2 * center - i;\n        if (i < right) {\n            radius[i] = Math.min(right - i, radius[mirror]);\n        }\n        while (transformed[i + 1 + radius[i]] == transformed[i - 1 - radius[i]]) {\n            radius[i]++;\n        }\n        if (i + radius[i] > right) {\n            center = i;\n            right = i + radius[i];\n        }\n    }\n    int maxLen = 0;\n    int centerIndex = 0;\n    for (int i = 1; i < n - 1; i++) {\n        if (radius[i] > maxLen) {\n            maxLen = radius[i];\n            centerIndex = i;\n        }\n    }\n    int start = (centerIndex - maxLen) / 2;\n    return s.substring(start, start + maxLen);\n}\n\nprivate char[] transform(String s) {\n    char[] result = new char[s.length() * 2 + 3];\n    result[0] = '^';\n    result[result.length - 1] = '$';\n    for (int i = 0; i < s.length(); i++) {\n        result[2 * i + 1] = '#';\n        result[2 * i + 2] = s.charAt(i);\n    }\n    result[result.length - 2] = '#';\n    return result;\n}\n",
      "cpp": "\nstd::string manacher(const std::string& s) {\n    std::string transformed = \"^#\";\n    for (char c : s) {\n        transformed += c;\n        transformed += '#';\n    }\n    transformed += '$';\n    int n = static_cast<int>(transformed.size());\n    std::vector<int> radius(n, 0);\n    int center = 0, right = 0;\n    for (int i = 1; i < n - 1; ++i) {\n        int mirror = 2 * center - i;\n        if (i < right) {\n            radius[i] = std::min(right - i, radius[mirror]);\n        }\n        while (transformed[i + radius[i] + 1] == transformed[i - radius[i] - 1]) {\n            ++radius[i];\n        }\n        if (i + radius[i] > right) {\n            center = i;\n            right = i + radius[i];\n        }\n    }\n    int max_len = 0;\n    int center_index = 0;\n    for (int i = 1; i < n - 1; ++i) {\n        if (radius[i] > max_len) {\n            max_len = radius[i];\n            center_index = i;\n        }\n    }\n    int start = (center_index - max_len) / 2;\n    return s.substr(start, max_len);\n}\n",
      "csharp": "\npublic string Manacher(string s) {\n    char[] transformed = Transform(s);\n    int n = transformed.Length;\n    var radius = new int[n];\n    int center = 0, right = 0;\n    for (int i = 1; i < n - 1; i++) {\n        int mirror = 2 * center - i;\n        if (i < right) {\n            radius[i] = Math.Min(right - i, radius[mirror]);\n        }\n        while (transformed[i + 1 + radius[i]] == transformed[i - 1 - radius[i]]) {\n            radius[i]++;\n        }\n        if (i + radius[i] > right) {\n            center = i;\n            right = i + radius[i];\n        }\n    }\n    int maxLen = 0;\n    int centerIndex = 0;\n    for (int i = 1; i < n - 1; i++) {\n        if (radius[i] > maxLen) {\n            maxLen = radius[i];\n            centerIndex = i;\n        }\n    }\n    int start = (centerIndex - maxLen) / 2;\n    return s.Substring(start, maxLen);\n}\n\nprivate char[] Transform(string s) {\n    char[] result = new char[s.Length * 2 + 3];\n    result[0] = '^';\n    result[result.Length - 1] = '$';\n    for (int i = 0; i < s.Length; i++) {\n        result[2 * i + 1] = '#';\n        result[2 * i + 2] = s[i];\n    }\n    result[result.Length - 2] = '#';\n    return result;\n}\n"
    },
    "steps": [
      {
        "title": "Transform string",
        "description": "Insert separators to handle even-length palindromes uniformly.",
        "frame": {
          "annotations": [
            "^#a#b#c#$"
          ]
        }
      },
      {
        "title": "Maintain center/radius",
        "description": "Reuse previous palindrome radius to skip checks when inside right boundary.",
        "frame": {
          "annotations": [
            "mirror index usage"
          ]
        }
      },
      {
        "title": "Extract result",
        "description": "Find maximum radius and convert back to original indices.",
        "frame": {
          "annotations": [
            "max radius -> substring"
          ]
        }
      }
    ]
  },
  {
    "id": "trie_prefix_tree",
    "name": "Trie (Prefix Tree)",
    "category": "Data Structures",
    "difficulty": "Beginner",
    "description": "A trie stores strings by branching on characters, enabling fast prefix queries and insertions.",
    "tags": [
      "string",
      "tree",
      "prefix"
    ],
    "complexity": {
      "best": "O(m)",
      "average": "O(m)",
      "worst": "O(m)",
      "space": "O(total characters)"
    },
    "codeSnippets": {
      "python": "\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def starts_with(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n",
      "java": "\npublic class Trie {\n    private static class Node {\n        Map<Character, Node> children = new HashMap<>();\n        boolean isEnd;\n    }\n\n    private final Node root = new Node();\n\n    public void insert(String word) {\n        Node node = root;\n        for (char ch : word.toCharArray()) {\n            node = node.children.computeIfAbsent(ch, c -> new Node());\n        }\n        node.isEnd = True;\n    }\n\n    public boolean search(String word) {\n        Node node = root;\n        for (char ch : word.toCharArray()) {\n            node = node.children.get(ch);\n            if (node == None) return False;\n        }\n        return node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        Node node = root;\n        for (char ch : prefix.toCharArray()) {\n            node = node.children.get(ch);\n            if (node == None) return False;\n        }\n        return True;\n    }\n}\n",
      "cpp": "\nstruct TrieNode {\n    std::array<TrieNode*, 26> children{};\n    bool is_end = False;\n    TrieNode() { children.fill(Noneptr); }\n};\n\nclass Trie {\n    TrieNode* root;\npublic:\n    Trie() : root(new TrieNode()) {}\n\n    void insert(const std::string& word) {\n        TrieNode* node = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!node->children[idx]) node->children[idx] = new TrieNode();\n            node = node->children[idx];\n        }\n        node->is_end = True;\n    }\n\n    bool search(const std::string& word) const {\n        TrieNode* node = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!node->children[idx]) return False;\n            node = node->children[idx];\n        }\n        return node->is_end;\n    }\n\n    bool starts_with(const std::string& prefix) const {\n        TrieNode* node = root;\n        for (char ch : prefix) {\n            int idx = ch - 'a';\n            if (!node->children[idx]) return False;\n            node = node->children[idx];\n        }\n        return True;\n    }\n};\n",
      "csharp": "\npublic sealed class Trie {\n    private sealed class Node {\n        public readonly Dictionary<char, Node> Children = new();\n        public bool IsEnd;\n    }\n\n    private readonly Node _root = new();\n\n    public void Insert(string word) {\n        var node = _root;\n        foreach (var ch in word) {\n            if (!node.Children.TryGetValue(ch, out var next)) {\n                next = new Node();\n                node.Children[ch] = next;\n            }\n            node = next;\n        }\n        node.IsEnd = True;\n    }\n\n    public bool Search(string word) {\n        var node = _root;\n        foreach (var ch in word) {\n            if (!node.Children.TryGetValue(ch, out node)) {\n                return False;\n            }\n        }\n        return node.IsEnd;\n    }\n\n    public bool StartsWith(string prefix) {\n        var node = _root;\n        foreach (var ch in prefix) {\n            if (!node.Children.TryGetValue(ch, out node)) {\n                return False;\n            }\n        }\n        return True;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Insert word",
        "description": "Traverse characters creating child nodes as needed and mark terminal node.",
        "frame": {
          "annotations": [
            "node.children[ch]"
          ]
        }
      },
      {
        "title": "Exact search",
        "description": "Follow characters; success if final node exists and is marked terminal.",
        "frame": {
          "annotations": [
            "node.is_end"
          ]
        }
      },
      {
        "title": "Prefix query",
        "description": "Verify prefix exists by traversing without requiring terminal flag.",
        "frame": {
          "annotations": [
            "prefix traversal"
          ]
        }
      }
    ]
  },
  {
    "id": "avl_tree_insertion",
    "name": "AVL Tree Insertion",
    "category": "Data Structures",
    "difficulty": "Advanced",
    "description": "AVL trees maintain height balance after insertions by performing rotations to keep height O(log n).",
    "tags": [
      "balanced tree",
      "rotations",
      "binary search tree"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(log n)"
    },
    "codeSnippets": {
      "python": "\nclass AVLNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\ndef height(node):\n    return node.height if node else 0\n\ndef rotate_right(y):\n    x = y.left\n    T2 = x.right\n    x.right = y\n    y.left = T2\n    y.height = 1 + max(height(y.left), height(y.right))\n    x.height = 1 + max(height(x.left), height(x.right))\n    return x\n\ndef rotate_left(x):\n    y = x.right\n    T2 = y.left\n    y.left = x\n    x.right = T2\n    x.height = 1 + max(height(x.left), height(x.right))\n    y.height = 1 + max(height(y.left), height(y.right))\n    return y\n\ndef get_balance(node):\n    return height(node.left) - height(node.right) if node else 0\n\ndef avl_insert(node, key):\n    if not node:\n        return AVLNode(key)\n    if key < node.key:\n        node.left = avl_insert(node.left, key)\n    elif key > node.key:\n        node.right = avl_insert(node.right, key)\n    else:\n        return node\n    node.height = 1 + max(height(node.left), height(node.right))\n    balance = get_balance(node)\n    if balance > 1 and key < node.left.key:\n        return rotate_right(node)\n    if balance < -1 and key > node.right.key:\n        return rotate_left(node)\n    if balance > 1 and key > node.left.key:\n        node.left = rotate_left(node.left)\n        return rotate_right(node)\n    if balance < -1 and key < node.right.key:\n        node.right = rotate_right(node.right)\n        return rotate_left(node)\n    return node\n",
      "java": "\npublic class AvlTree {\n    private static class Node {\n        int key, height;\n        Node left, right;\n        Node(int key) { this.key = key; this.height = 1; }\n    }\n\n    private Node root;\n\n    public void insert(int key) {\n        root = insert(root, key);\n    }\n\n    private Node insert(Node node, int key) {\n        if (node == None) return new Node(key);\n        if (key < node.key) {\n            node.left = insert(node.left, key);\n        } else if (key > node.key) {\n            node.right = insert(node.right, key);\n        } else {\n            return node;\n        }\n        node.height = 1 + Math.max(height(node.left), height(node.right));\n        int balance = balance(node);\n        if (balance > 1 && key < node.left.key) return rotateRight(node);\n        if (balance < -1 && key > node.right.key) return rotateLeft(node);\n        if (balance > 1 && key > node.left.key) {\n            node.left = rotateLeft(node.left);\n            return rotateRight(node);\n        }\n        if (balance < -1 && key < node.right.key) {\n            node.right = rotateRight(node.right);\n            return rotateLeft(node);\n        }\n        return node;\n    }\n\n    private int height(Node node) {\n        return node == None ? 0 : node.height;\n    }\n\n    private int balance(Node node) {\n        return node == None ? 0 : height(node.left) - height(node.right);\n    }\n\n    private Node rotateRight(Node y) {\n        Node x = y.left;\n        Node T2 = x.right;\n        x.right = y;\n        y.left = T2;\n        y.height = Math.max(height(y.left), height(y.right)) + 1;\n        x.height = Math.max(height(x.left), height(x.right)) + 1;\n        return x;\n    }\n\n    private Node rotateLeft(Node x) {\n        Node y = x.right;\n        Node T2 = y.left;\n        y.left = x;\n        x.right = T2;\n        x.height = Math.max(height(x.left), height(x.right)) + 1;\n        y.height = Math.max(height(y.left), height(y.right)) + 1;\n        return y;\n    }\n}\n",
      "cpp": "\nstruct AvlNode {\n    int key;\n    int height;\n    AvlNode* left;\n    AvlNode* right;\n    explicit AvlNode(int k) : key(k), height(1), left(Noneptr), right(Noneptr) {}\n};\n\nint height(AvlNode* node) { return node ? node->height : 0; }\n\nAvlNode* rotate_right(AvlNode* y) {\n    AvlNode* x = y->left;\n    AvlNode* T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    y->height = std::max(height(y->left), height(y->right)) + 1;\n    x->height = std::max(height(x->left), height(x->right)) + 1;\n    return x;\n}\n\nAvlNode* rotate_left(AvlNode* x) {\n    AvlNode* y = x->right;\n    AvlNode* T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    x->height = std::max(height(x->left), height(x->right)) + 1;\n    y->height = std::max(height(y->left), height(y->right)) + 1;\n    return y;\n}\n\nint balance_factor(AvlNode* node) {\n    return node ? height(node->left) - height(node->right) : 0;\n}\n\nAvlNode* avl_insert(AvlNode* node, int key) {\n    if (!node) return new AvlNode(key);\n    if (key < node->key) node->left = avl_insert(node->left, key);\n    else if (key > node->key) node->right = avl_insert(node->right, key);\n    else return node;\n    node->height = 1 + std::max(height(node->left), height(node->right));\n    int balance = balance_factor(node);\n    if (balance > 1 && key < node->left->key) return rotate_right(node);\n    if (balance < -1 && key > node->right->key) return rotate_left(node);\n    if (balance > 1 && key > node->left->key) {\n        node->left = rotate_left(node->left);\n        return rotate_right(node);\n    }\n    if (balance < -1 && key < node->right->key) {\n        node->right = rotate_right(node->right);\n        return rotate_left(node);\n    }\n    return node;\n}\n",
      "csharp": "\npublic sealed class AvlTree {\n    private sealed class Node {\n        public int Key;\n        public int Height;\n        public Node Left;\n        public Node Right;\n        public Node(int key) { Key = key; Height = 1; }\n    }\n\n    private Node _root;\n\n    public void Insert(int key) {\n        _root = Insert(_root, key);\n    }\n\n    private Node Insert(Node node, int key) {\n        if (node == None) return new Node(key);\n        if (key < node.Key) node.Left = Insert(node.Left, key);\n        else if (key > node.Key) node.Right = Insert(node.Right, key);\n        else return node;\n        UpdateHeight(node);\n        return Rebalance(node, key);\n    }\n\n    private void UpdateHeight(Node node) {\n        node.Height = 1 + Math.Max(Height(node.Left), Height(node.Right));\n    }\n\n    private Node Rebalance(Node node, int key) {\n        int balance = Height(node.Left) - Height(node.Right);\n        if (balance > 1 && key < node.Left.Key) return RotateRight(node);\n        if (balance < -1 && key > node.Right.Key) return RotateLeft(node);\n        if (balance > 1 && key > node.Left.Key) {\n            node.Left = RotateLeft(node.Left);\n            return RotateRight(node);\n        }\n        if (balance < -1 && key < node.Right.Key) {\n            node.Right = RotateRight(node.Right);\n            return RotateLeft(node);\n        }\n        return node;\n    }\n\n    private int Height(Node node) => node?.Height ?? 0;\n\n    private Node RotateRight(Node y) {\n        var x = y.Left;\n        var T2 = x.Right;\n        x.Right = y;\n        y.Left = T2;\n        UpdateHeight(y);\n        UpdateHeight(x);\n        return x;\n    }\n\n    private Node RotateLeft(Node x) {\n        var y = x.Right;\n        var T2 = y.Left;\n        y.Left = x;\n        x.Right = T2;\n        UpdateHeight(x);\n        UpdateHeight(y);\n        return y;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "Standard BST insert",
        "description": "Insert node as in binary search tree.",
        "frame": {
          "annotations": [
            "recursive BST insert"
          ]
        }
      },
      {
        "title": "Update heights",
        "description": "After insertion, recompute node heights bottom-up.",
        "frame": {
          "annotations": [
            "height = 1 + max(left,right)"
          ]
        }
      },
      {
        "title": "Rotate to balance",
        "description": "Apply rotations based on balance factor to restore AVL property.",
        "frame": {
          "annotations": [
            "LL, RR, LR, RL cases"
          ]
        }
      }
    ]
  },
  {
    "id": "red_black_tree_insertion",
    "name": "Red-Black Tree Insertion",
    "category": "Data Structures",
    "difficulty": "Advanced",
    "description": "Maintains balanced binary search tree with color constraints, applying rotations and recoloring after insertions.",
    "tags": [
      "balanced tree",
      "red-black",
      "rotations"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(log n)"
    },
    "codeSnippets": {
      "python": "\nclass RBNode:\n    def __init__(self, key, color='RED'):\n        self.key = key\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\nclass RedBlackTree:\n    def __init__(self):\n        self.nil = RBNode(None, color='BLACK')\n        self.root = self.nil\n\n    def rotate_left(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left != self.nil:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def rotate_right(self, y):\n        x = y.left\n        y.left = x.right\n        if x.right != self.nil:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent is None:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        node = RBNode(key)\n        node.left = node.right = self.nil\n        parent = None\n        current = self.root\n        while current != self.nil:\n            parent = current\n            if node.key < current.key:\n                current = current.left\n            else:\n                current = current.right\n        node.parent = parent\n        if parent is None:\n            self.root = node\n        elif node.key < parent.key:\n            parent.left = node\n        else:\n            parent.right = node\n        node.color = 'RED'\n        self._fix_insert(node)\n\n    def _fix_insert(self, node):\n        while node.parent and node.parent.color == 'RED':\n            if node.parent == node.parent.parent.left:\n                uncle = node.parent.parent.right\n                if uncle.color == 'RED':\n                    node.parent.color = 'BLACK'\n                    uncle.color = 'BLACK'\n                    node.parent.parent.color = 'RED'\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.right:\n                        node = node.parent\n                        self.rotate_left(node)\n                    node.parent.color = 'BLACK'\n                    node.parent.parent.color = 'RED'\n                    self.rotate_right(node.parent.parent)\n            else:\n                uncle = node.parent.parent.left\n                if uncle.color == 'RED':\n                    node.parent.color = 'BLACK'\n                    uncle.color = 'BLACK'\n                    node.parent.parent.color = 'RED'\n                    node = node.parent.parent\n                else:\n                    if node == node.parent.left:\n                        node = node.parent\n                        self.rotate_right(node)\n                    node.parent.color = 'BLACK'\n                    node.parent.parent.color = 'RED'\n                    self.rotate_left(node.parent.parent)\n        self.root.color = 'BLACK'\n",
      "java": "\npublic class RedBlackTree {\n    private static final boolean RED = True;\n    private static final boolean BLACK = False;\n\n    private static class Node {\n        int key;\n        boolean color;\n        Node left, right, parent;\n        Node(int key) { this.key = key; this.color = RED; }\n    }\n\n    private Node root;\n\n    public void insert(int key) {\n        Node node = new Node(key);\n        insertNode(node);\n        fixInsert(node);\n    }\n\n    private void insertNode(Node node) {\n        Node parent = None;\n        Node current = root;\n        while (current != None) {\n            parent = current;\n            current = node.key < current.key ? current.left : current.right;\n        }\n        node.parent = parent;\n        if (parent == None) {\n            root = node;\n        } else if (node.key < parent.key) {\n            parent.left = node;\n        } else {\n            parent.right = node;\n        }\n    }\n\n    private void rotateLeft(Node x) {\n        Node y = x.right;\n        x.right = y.left;\n        if (y.left != None) y.left.parent = x;\n        y.parent = x.parent;\n        if (x.parent == None) root = y;\n        else if (x == x.parent.left) x.parent.left = y;\n        else x.parent.right = y;\n        y.left = x;\n        x.parent = y;\n    }\n\n    private void rotateRight(Node y) {\n        Node x = y.left;\n        y.left = x.right;\n        if (x.right != None) x.right.parent = y;\n        x.parent = y.parent;\n        if (y.parent == None) root = x;\n        else if (y == y.parent.right) y.parent.right = x;\n        else y.parent.left = x;\n        x.right = y;\n        y.parent = x;\n    }\n\n    private void fixInsert(Node node) {\n        while (node != root && node.parent.color == RED) {\n            if (node.parent == node.parent.parent.left) {\n                Node uncle = node.parent.parent.right;\n                if (uncle != None && uncle.color == RED) {\n                    node.parent.color = BLACK;\n                    uncle.color = BLACK;\n                    node.parent.parent.color = RED;\n                    node = node.parent.parent;\n                } else {\n                    if (node == node.parent.right) {\n                        node = node.parent;\n                        rotateLeft(node);\n                    }\n                    node.parent.color = BLACK;\n                    node.parent.parent.color = RED;\n                    rotateRight(node.parent.parent);\n                }\n            } else {\n                Node uncle = node.parent.parent.left;\n                if (uncle != None && uncle.color == RED) {\n                    node.parent.color = BLACK;\n                    uncle.color = BLACK;\n                    node.parent.parent.color = RED;\n                    node = node.parent.parent;\n                } else {\n                    if (node == node.parent.left) {\n                        node = node.parent;\n                        rotateRight(node);\n                    }\n                    node.parent.color = BLACK;\n                    node.parent.parent.color = RED;\n                    rotateLeft(node.parent.parent);\n                }\n            }\n        }\n        root.color = BLACK;\n    }\n}\n",
      "cpp": "\nenum Color { RED, BLACK };\n\nstruct RBNode {\n    int key;\n    Color color;\n    RBNode* left;\n    RBNode* right;\n    RBNode* parent;\n    explicit RBNode(int k) : key(k), color(RED), left(Noneptr), right(Noneptr), parent(Noneptr) {}\n};\n\nclass RedBlackTree {\n    RBNode* root = Noneptr;\n\n    void rotate_left(RBNode* x) {\n        RBNode* y = x->right;\n        x->right = y->left;\n        if (y->left) y->left->parent = x;\n        y->parent = x->parent;\n        if (!x->parent) root = y;\n        else if (x == x->parent->left) x->parent->left = y;\n        else x->parent->right = y;\n        y->left = x;\n        x->parent = y;\n    }\n\n    void rotate_right(RBNode* y) {\n        RBNode* x = y->left;\n        y->left = x->right;\n        if (x->right) x->right->parent = y;\n        x->parent = y->parent;\n        if (!y->parent) root = x;\n        else if (y == y->parent->right) y->parent->right = x;\n        else y->parent->left = x;\n        x->right = y;\n        y->parent = x;\n    }\n\n    void fix_insert(RBNode* node) {\n        while (node->parent && node->parent->color == RED) {\n            if (node->parent == node->parent->parent->left) {\n                RBNode* uncle = node->parent->parent->right;\n                if (uncle && uncle->color == RED) {\n                    node->parent->color = BLACK;\n                    uncle->color = BLACK;\n                    node->parent->parent->color = RED;\n                    node = node->parent->parent;\n                } else {\n                    if (node == node->parent->right) {\n                        node = node->parent;\n                        rotate_left(node);\n                    }\n                    node->parent->color = BLACK;\n                    node->parent->parent->color = RED;\n                    rotate_right(node->parent->parent);\n                }\n            } else {\n                RBNode* uncle = node->parent->parent->left;\n                if (uncle && uncle->color == RED) {\n                    node->parent->color = BLACK;\n                    uncle->color = BLACK;\n                    node->parent->parent->color = RED;\n                    node = node->parent->parent;\n                } else {\n                    if (node == node->parent->left) {\n                        node = node->parent;\n                        rotate_right(node);\n                    }\n                    node->parent->color = BLACK;\n                    node->parent->parent->color = RED;\n                    rotate_left(node->parent->parent);\n                }\n            }\n        }\n        root->color = BLACK;\n    }\n\npublic:\n    void insert(int key) {\n        RBNode* node = new RBNode(key);\n        RBNode* parent = Noneptr;\n        RBNode* current = root;\n        while (current) {\n            parent = current;\n            current = node->key < current->key ? current->left : current->right;\n        }\n        node->parent = parent;\n        if (!parent) root = node;\n        else if (node->key < parent->key) parent->left = node;\n        else parent->right = node;\n        fix_insert(node);\n    }\n};\n",
      "csharp": "\npublic sealed class RedBlackTree {\n    private const bool Red = True;\n    private const bool Black = False;\n\n    private sealed class Node {\n        public int Key;\n        public bool Color;\n        public Node Left;\n        public Node Right;\n        public Node Parent;\n        public Node(int key) { Key = key; Color = Red; }\n    }\n\n    private Node _root;\n\n    public void Insert(int key) {\n        var node = new Node(key);\n        InsertNode(node);\n        FixInsert(node);\n    }\n\n    private void InsertNode(Node node) {\n        Node parent = None;\n        var current = _root;\n        while (current != None) {\n            parent = current;\n            current = node.Key < current.Key ? current.Left : current.Right;\n        }\n        node.Parent = parent;\n        if (parent == None) _root = node;\n        else if (node.Key < parent.Key) parent.Left = node;\n        else parent.Right = node;\n    }\n\n    private void RotateLeft(Node x) {\n        var y = x.Right;\n        x.Right = y.Left;\n        if (y.Left != None) y.Left.Parent = x;\n        y.Parent = x.Parent;\n        if (x.Parent == None) _root = y;\n        else if (x == x.Parent.Left) x.Parent.Left = y;\n        else x.Parent.Right = y;\n        y.Left = x;\n        x.Parent = y;\n    }\n\n    private void RotateRight(Node y) {\n        var x = y.Left;\n        y.Left = x.Right;\n        if (x.Right != None) x.Right.Parent = y;\n        x.Parent = y.Parent;\n        if (y.Parent == None) _root = x;\n        else if (y == y.Parent.Right) y.Parent.Right = x;\n        else y.Parent.Left = x;\n        x.Right = y;\n        y.Parent = x;\n    }\n\n    private void FixInsert(Node node) {\n        while (node != _root && node.Parent.Color == Red) {\n            if (node.Parent == node.Parent.Parent.Left) {\n                var uncle = node.Parent.Parent.Right;\n                if (uncle != None && uncle.Color == Red) {\n                    node.Parent.Color = Black;\n                    uncle.Color = Black;\n                    node.Parent.Parent.Color = Red;\n                    node = node.Parent.Parent;\n                } else {\n                    if (node == node.Parent.Right) {\n                        node = node.Parent;\n                        RotateLeft(node);\n                    }\n                    node.Parent.Color = Black;\n                    node.Parent.Parent.Color = Red;\n                    RotateRight(node.Parent.Parent);\n                }\n            } else {\n                var uncle = node.Parent.Parent.Left;\n                if (uncle != None && uncle.Color == Red) {\n                    node.Parent.Color = Black;\n                    uncle.Color = Black;\n                    node.Parent.Parent.Color = Red;\n                    node = node.Parent.Parent;\n                } else {\n                    if (node == node.Parent.Left) {\n                        node = node.Parent;\n                        RotateRight(node);\n                    }\n                    node.Parent.Color = Black;\n                    node.Parent.Parent.Color = Red;\n                    RotateLeft(node.Parent.Parent);\n                }\n            }\n        }\n        _root.Color = Black;\n    }\n}\n"
    },
    "steps": [
      {
        "title": "BST insert red node",
        "description": "Insert new node as red in standard BST position.",
        "frame": {
          "annotations": [
            "new node color = red"
          ]
        }
      },
      {
        "title": "Fix double red",
        "description": "While parent is red, recolor or rotate depending on uncle color.",
        "frame": {
          "annotations": [
            "case analysis with uncle"
          ]
        }
      },
      {
        "title": "Ensure root black",
        "description": "Finish by enforcing root color black to satisfy red-black properties.",
        "frame": {
          "annotations": [
            "root.color = black"
          ]
        }
      }
    ]
  },
  {
    "id": "quickselect",
    "name": "Quickselect (k-th Order Statistic)",
    "category": "Search & Sort",
    "difficulty": "Intermediate",
    "description": "Quickselect partitions the array around a pivot, recursing into the side containing the k-th element, yielding expected linear time.",
    "tags": [
      "selection",
      "divide and conquer",
      "pivot"
    ],
    "complexity": {
      "best": "O(n)",
      "average": "O(n)",
      "worst": "O(n^2)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\nimport random\n\ndef quickselect(arr, k):\n    if not 0 <= k < len(arr):\n        raise IndexError('k out of range')\n    left, right = 0, len(arr) - 1\n    while True:\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(arr, left, right, pivot_index)\n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            right = pivot_index - 1\n        else:\n            left = pivot_index + 1\n\ndef partition(arr, left, right, pivot_index):\n    pivot_value = arr[pivot_index]\n    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]\n    store_index = left\n    for i in range(left, right):\n        if arr[i] < pivot_value:\n            arr[store_index], arr[i] = arr[i], arr[store_index]\n            store_index += 1\n    arr[right], arr[store_index] = arr[store_index], arr[right]\n    return store_index\n",
      "java": "\npublic int quickselect(int[] arr, int k) {\n    if (k < 0 || k >= arr.length) throw new IllegalArgumentException(\"k out of range\");\n    int left = 0, right = arr.length - 1;\n    var random = ThreadLocalRandom.current();\n    while (True) {\n        int pivotIndex = random.nextInt(left, right + 1);\n        pivotIndex = partition(arr, left, right, pivotIndex);\n        if (k == pivotIndex) return arr[k];\n        if (k < pivotIndex) right = pivotIndex - 1;\n        else left = pivotIndex + 1;\n    }\n}\n\nprivate int partition(int[] arr, int left, int right, int pivotIndex) {\n    int pivotValue = arr[pivotIndex];\n    swap(arr, pivotIndex, right);\n    int storeIndex = left;\n    for (int i = left; i < right; i++) {\n        if (arr[i] < pivotValue) {\n            swap(arr, storeIndex++, i);\n        }\n    }\n    swap(arr, right, storeIndex);\n    return storeIndex;\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n",
      "cpp": "\nint partition(std::vector<int>& arr, int left, int right, int pivot_index) {\n    int pivot_value = arr[pivot_index];\n    std::swap(arr[pivot_index], arr[right]);\n    int store_index = left;\n    for (int i = left; i < right; ++i) {\n        if (arr[i] < pivot_value) {\n            std::swap(arr[store_index++], arr[i]);\n        }\n    }\n    std::swap(arr[right], arr[store_index]);\n    return store_index;\n}\n\nint quickselect(std::vector<int> arr, int k) {\n    if (k < 0 || k >= static_cast<int>(arr.size())) throw std::out_of_range(\"k\");\n    int left = 0, right = static_cast<int>(arr.size()) - 1;\n    std::mt19937 gen(std::random_device{}());\n    while (True) {\n        std::uniform_int_distribution<int> dist(left, right);\n        int pivot_index = dist(gen);\n        pivot_index = partition(arr, left, right, pivot_index);\n        if (k == pivot_index) return arr[k];\n        if (k < pivot_index) right = pivot_index - 1;\n        else left = pivot_index + 1;\n    }\n}\n",
      "csharp": "\npublic int Quickselect(int[] arr, int k) {\n    if (k < 0 || k >= arr.Length) throw new ArgumentOutOfRangeException(nameof(k));\n    int left = 0, right = arr.Length - 1;\n    var random = new Random();\n    while (True) {\n        int pivotIndex = random.Next(left, right + 1);\n        pivotIndex = Partition(arr, left, right, pivotIndex);\n        if (k == pivotIndex) return arr[k];\n        if (k < pivotIndex) right = pivotIndex - 1;\n        else left = pivotIndex + 1;\n    }\n}\n\nprivate int Partition(int[] arr, int left, int right, int pivotIndex) {\n    int pivotValue = arr[pivotIndex];\n    (arr[pivotIndex], arr[right]) = (arr[right], arr[pivotIndex]);\n    int storeIndex = left;\n    for (int i = left; i < right; i++) {\n        if (arr[i] < pivotValue) {\n            (arr[storeIndex], arr[i]) = (arr[i], arr[storeIndex]);\n            storeIndex++;\n        }\n    }\n    (arr[right], arr[storeIndex]) = (arr[storeIndex], arr[right]);\n    return storeIndex;\n}\n"
    },
    "steps": [
      {
        "title": "Partition array",
        "description": "Place pivot at correct position with elements smaller on left and larger on right.",
        "frame": {
          "annotations": [
            "partition around pivot"
          ]
        }
      },
      {
        "title": "Recurse on appropriate side",
        "description": "Discard half not containing k, focusing on relevant side.",
        "frame": {
          "annotations": [
            "adjust left/right"
          ]
        }
      },
      {
        "title": "Return k-th element",
        "description": "When pivot index equals k, return value.",
        "frame": {
          "annotations": [
            "arr[k] is answer"
          ]
        }
      }
    ]
  },
  {
    "id": "ternary_search_unimodal",
    "name": "Ternary Search on Unimodal Function",
    "category": "Optimization",
    "difficulty": "Intermediate",
    "description": "Ternary search narrows down the maximum or minimum of a unimodal function by evaluating at two interior points each iteration.",
    "tags": [
      "optimization",
      "search",
      "unimodal"
    ],
    "complexity": {
      "best": "O(log n)",
      "average": "O(log n)",
      "worst": "O(log n)",
      "space": "O(1)"
    },
    "codeSnippets": {
      "python": "\ndef ternary_search(lo, hi, f, iterations=100):\n    for _ in range(iterations):\n        mid1 = lo + (hi - lo) / 3\n        mid2 = hi - (hi - lo) / 3\n        if f(mid1) < f(mid2):\n            lo = mid1\n        else:\n            hi = mid2\n    return (lo + hi) / 2\n",
      "java": "\npublic double ternarySearch(double lo, double hi, DoubleUnaryOperator f, int iterations) {\n    for (int i = 0; i < iterations; i++) {\n        double mid1 = lo + (hi - lo) / 3.0;\n        double mid2 = hi - (hi - lo) / 3.0;\n        if (f.applyAsDouble(mid1) < f.applyAsDouble(mid2)) {\n            lo = mid1;\n        } else {\n            hi = mid2;\n        }\n    }\n    return (lo + hi) / 2.0;\n}\n",
      "cpp": "\ndouble ternary_search(double lo, double hi, const std::function<double(double)>& f, int iterations = 100) {\n    for (int i = 0; i < iterations; ++i) {\n        double mid1 = lo + (hi - lo) / 3.0;\n        double mid2 = hi - (hi - lo) / 3.0;\n        if (f(mid1) < f(mid2)) {\n            lo = mid1;\n        } else {\n            hi = mid2;\n        }\n    }\n    return (lo + hi) / 2.0;\n}\n",
      "csharp": "\npublic double TernarySearch(double lo, double hi, Func<double, double> f, int iterations = 100) {\n    for (int i = 0; i < iterations; i++) {\n        double mid1 = lo + (hi - lo) / 3.0;\n        double mid2 = hi - (hi - lo) / 3.0;\n        if (f(mid1) < f(mid2)) {\n            lo = mid1;\n        } else {\n            hi = mid2;\n        }\n    }\n    return (lo + hi) / 2.0;\n}\n"
    },
    "steps": [
      {
        "title": "Evaluate two midpoints",
        "description": "Split current interval into thirds and evaluate function at mid1 and mid2.",
        "frame": {
          "annotations": [
            "mid1, mid2 within [lo, hi]"
          ]
        }
      },
      {
        "title": "Discard worst segment",
        "description": "Depending on unimodal property, adjust lo or hi to shrink interval.",
        "frame": {
          "annotations": [
            "keep segment containing optimum"
          ]
        }
      },
      {
        "title": "Iterate to convergence",
        "description": "Repeat until interval sufficiently small.",
        "frame": {
          "annotations": [
            "loop until hi-lo small"
          ]
        }
      }
    ]
  },
  {
    "id": "a_star_search",
    "name": "A* Search",
    "category": "Graph Theory",
    "difficulty": "Advanced",
    "description": "A* uses a heuristic to guide search towards the goal, combining actual cost g(n) with estimated cost h(n) to prioritize nodes.",
    "tags": [
      "pathfinding",
      "heuristic",
      "priority queue"
    ],
    "complexity": {
      "best": "O(E)",
      "average": "O(E log V)",
      "worst": "O(E log V)",
      "space": "O(V)"
    },
    "codeSnippets": {
      "python": "\nimport heapq\n\ndef a_star(start, goal, neighbors, heuristic):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == goal:\n            return reconstruct_path(came_from, current)\n        for neighbor, cost in neighbors(current):\n            tentative_g = g_score[current] + cost\n            if tentative_g < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, neighbor))\n    return None\n\ndef reconstruct_path(came_from, current):\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    return list(reversed(path))\n",
      "java": "\npublic List<Node> aStar(Node start, Node goal, Function<Node, List<Edge>> neighbors, ToDoubleBiFunction<Node, Node> heuristic) {\n    PriorityQueue<State> open = new PriorityQueue<>(Comparator.comparingDouble(state -> state.f));\n    Map<Node, Node> cameFrom = new HashMap<>();\n    Map<Node, Double> gScore = new HashMap<>();\n    gScore.put(start, 0.0);\n    open.add(new State(start, heuristic.applyAsDouble(start, goal)));\n    while (!open.isEmpty()) {\n        State currentState = open.poll();\n        Node current = currentState.node;\n        if (current.equals(goal)) {\n            return reconstructPath(cameFrom, current);\n        }\n        for (Edge edge : neighbors.apply(current)) {\n            Node neighbor = edge.to();\n            double tentativeG = gScore.get(current) + edge.weight();\n            if (tentativeG < gScore.getOrDefault(neighbor, Double.POSITIVE_INFINITY)) {\n                cameFrom.put(neighbor, current);\n                gScore.put(neighbor, tentativeG);\n                double fScore = tentativeG + heuristic.applyAsDouble(neighbor, goal);\n                open.add(new State(neighbor, fScore));\n            }\n        }\n    }\n    return None;\n}\n\nprivate List<Node> reconstructPath(Map<Node, Node> cameFrom, Node current) {\n    LinkedList<Node> path = new LinkedList<>();\n    path.addFirst(current);\n    while (cameFrom.containsKey(current)) {\n        current = cameFrom.get(current);\n        path.addFirst(current);\n    }\n    return path;\n}\n\nprivate record State(Node node, double f) {}\n",
      "cpp": "\nstruct Edge { int to; double weight; };\n\nstd::vector<int> a_star(int start, int goal,\n                        const std::function<std::vector<Edge>(int)>& neighbors,\n                        const std::function<double(int, int)>& heuristic) {\n    using State = std::pair<double, int>;\n    std::priority_queue<State, std::vector<State>, std::greater<State>> open;\n    std::unordered_map<int, int> came_from;\n    std::unordered_map<int, double> g_score{{start, 0.0}};\n    open.emplace(heuristic(start, goal), start);\n    while (!open.empty()) {\n        auto [_, current] = open.top();\n        open.pop();\n        if (current == goal) {\n            std::vector<int> path;\n            for (int node = current; ; node = came_from[node]) {\n                path.push_back(node);\n                if (node == start) break;\n            }\n            std::reverse(path.begin(), path.end());\n            return path;\n        }\n        for (const auto& edge : neighbors(current)) {\n            double tentative = g_score[current] + edge.weight;\n            if (!g_score.count(edge.to) || tentative < g_score[edge.to]) {\n                came_from[edge.to] = current;\n                g_score[edge.to] = tentative;\n                double f = tentative + heuristic(edge.to, goal);\n                open.emplace(f, edge.to);\n            }\n        }\n    }\n    return {};\n}\n",
      "csharp": "\npublic IList<TNode> AStar<TNode>(TNode start, TNode goal,\n    Func<TNode, IEnumerable<(TNode neighbor, double cost)>> neighbors,\n    Func<TNode, TNode, double> heuristic) {\n    var open = new PriorityQueue<TNode, double>();\n    var cameFrom = new Dictionary<TNode, TNode>();\n    var gScore = new Dictionary<TNode, double> { [start] = 0 };\n    open.Enqueue(start, heuristic(start, goal));\n    while (open.Count > 0) {\n        var current = open.Dequeue();\n        if (EqualityComparer<TNode>.Default.Equals(current, goal)) {\n            return ReconstructPath(cameFrom, current);\n        }\n        foreach (var (neighbor, cost) in neighbors(current)) {\n            double tentative = gScore[current] + cost;\n            if (!gScore.TryGetValue(neighbor, out var existing) || tentative < existing) {\n                cameFrom[neighbor] = current;\n                gScore[neighbor] = tentative;\n                double f = tentative + heuristic(neighbor, goal);\n                open.Enqueue(neighbor, f);\n            }\n        }\n    }\n    return None;\n}\n\nprivate IList<TNode> ReconstructPath<TNode>(IDictionary<TNode, TNode> cameFrom, TNode current) {\n    var path = new List<TNode> { current };\n    while (cameFrom.TryGetValue(current, out var parent)) {\n        current = parent;\n        path.Add(current);\n    }\n    path.Reverse();\n    return path;\n}\n"
    },
    "steps": [
      {
        "title": "Initialize frontier",
        "description": "Start with open set containing source and g-score 0.",
        "frame": {
          "annotations": [
            "open_set <- start"
          ]
        }
      },
      {
        "title": "Expand lowest f-score",
        "description": "Pop node with lowest g + h, relax neighbors updating g-score and priority.",
        "frame": {
          "annotations": [
            "f = g + h"
          ]
        }
      },
      {
        "title": "Reconstruct path",
        "description": "When goal extracted, backtrack using parent map.",
        "frame": {
          "annotations": [
            "came_from map"
          ]
        }
      }
    ]
  }
]